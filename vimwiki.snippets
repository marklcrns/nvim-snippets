# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# Mathjax snippets reference:
# https://github.com/gillescastel/latex-snippets/blob/master/tex.snippets

global !p
import os, re
from datetime import datetime, timedelta, date

def math():
    return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment():
    return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
    [x,y] = vim.eval("vimtex#env#is_inside('" + name + "')")
    return x != '0' and x != '0'

def get_wiki_files_dir():
	root = os.getcwd()
	rel_path = re.sub(root, '', path)			# strip root dir from abs filepath
	dir_path = re.sub(fn, '', rel_path) # remove current buffer file from path
	subdir_count = 0
	wiki_path = ''

	try:
		if 'md/' in dir_path:
			file_index_end =  dir_path.index('md/') + 2 # Get the end index of 'md' dir
			stripped_path = dir_path[file_index_end:]		# Strip trailing path from after 'md' dir
			wiki_path = dir_path[file_index_end + 1:]
			# Count how deep current buffer dir relative to 'md' dir or stripped path
			for i in stripped_path:
				if i == '/':
					subdir_count += 1
	except ValueError:
		return # Return nothing if no 'md' dir

	# return path to 'files/' dir relative to current buffer dir
	return "../" * subdir_count + "files/" + wiki_path


def get_nearest_glossary():
	bib='glossary.md'

	if fn in bib: return ''

	abs_path = os.path.abspath(path)
	dir_path = os.path.dirname(abs_path) # remove current file from path
	subdir_count = 0
	wiki_path = ''

	while '/md/' in dir_path:
		if os.path.exists(dir_path + '/' + bib): break
		dir_path = os.path.dirname(dir_path)
		subdir_count += 1

	return "../" * subdir_count + bib


# Make all multi-line placeholder strings jumpable.
def create_matrix_placeholders(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""

	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]

  # Append current line into anonymous snippet
	for i in range(start, end + 1):
		anon_snippet_body += snip.buffer[i]
		anon_snippet_body += "" if i == end else "\n"

	# Delete expanded snippet line till second to last line
	for i in range(start, end):
		del snip.buffer[start]

	# Empty last expanded snippet line while preserving the line
	snip.buffer[start] = ''

	# Expand anonymous snippet
	snip.expand_anon(anon_snippet_body)


def create_matrix(cols, rows, sep, start, end):
	res = ""
	placeholder = 1
	for _ in range(0, int(rows)):
		res += start + f"${placeholder}"
		placeholder += 1
		for _ in range(0, int(cols) - 1):
			res += sep + f"${placeholder}"
			placeholder += 1
		res += end
	return res[:-1]


def get_parent_header(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""
	# Get start of snippet as the end of line
	end = snip.snippet_start[0]

	# Append current line into anonymous snippet
	for i in reversed(range(0, end)):
		if (snip.buffer[i].find('#') == 0):
			return snip.buffer[i]

	return ""


# Gets next day of the week. Returns today's date if, say '6' was passed in, and
# today is sunday.
# Sample usage: get_next_week_date(6, 1), will return the date of next "Sunday"
# Sample usage: get_next_week_date(0, 2), will return the date of next next "Monday"
# https://stackoverflow.com/a/8801197/11850077
def get_next_week_date(week_date, next_date):
	day = date.today()
	i = 0
	while i != next_date:
		day += timedelta(1)
		if day.weekday() == week_date:
			i += 1
	return day


# Same as get_next_week_date() but for last week instead.
def get_last_week_date(week_date, last_date):
	day = date.today()
	i = 0
	while i != last_date:
		day -= timedelta(1)
		if day.weekday() == week_date:
			i += 1
	return day


def get_date_from_now(next_date):
	day = date.today() + timedelta(next_date)
	return day


# https://stackoverflow.com/a/13565185/11850077
def get_last_day_of_month(ref_date):
	end = ref_date.replace(day=28) + timedelta(days=4)  # this will never fail
	end = end - timedelta(days=end.day)
	return end


# https://stackoverflow.com/a/59199379/11850077
def get_start_of_next_month(ref_date):
    start = (ref_date.replace(day=1) + timedelta(days=32)).replace(day=1)
    return start

# Mathjax matrix dictionary
boundaries = {
	"b": ["[", "]"],
	"B": ["\\\{", "\\\}"],
	"p": ["(", ")"],
	"v": ["|", "|"],
	"V": ["||", "||"]
}

weekdays = {
	"0": "Monday",
	"1": "Tuesday",
	"2": "Wednesday",
	"3": "Thursday",
	"4": "Friday",
	"5": "Saturday",
	"6": "Sunday"
}

# Todo meds task
def create_meds_task_head(desc, time):
	time = int(time)
	str_date_time = ""

	if time > 2399:
		time = time - 2400

	if time > 999:
		str_date_time += str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 1000 and time > 99:
		str_date_time += "0" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 100 and time > 0:
		str_date_time += "00" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time == 0:
		str_date_time += "00:00"

	str_date_time = "(" + tomorrow + " " + str_date_time + ")"

	task =  desc + " " + str_date_time
	return task

def create_meds_task(desc, time, offset):
	time = int(time) + (offset)
	date = today
	str_time = ""
	str_date_time = ""

	if time > 2399:
		time = time - 2400
		date = tomorrow

	if time > 999:
		str_time += str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 1000 and time > 99:
		str_time += "0" + str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += "0" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 100 and time > 0:
		str_time += "00" + str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += "00" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time == 0:
		str_time += "00:00"
		str_date_time += "00:00"

	str_date_time = "(" + date + " " + str_date_time + ")"

	task =  str_time + " " + desc + " " + str_date_time
	return task

def strip_emojis(text):
	emoji_pattern = re.compile("["
			u"\U0001F600-\U0001F64F"  # emoticons
			u"\U0001F300-\U0001F5FF"  # symbols & pictographs
			u"\U0001F680-\U0001F6FF"  # transport & map symbols
			u"\U0001F1E0-\U0001F1FF"  # flags (iOS)
			"]+", flags=re.UNICODE)

	return emoji_pattern.sub(r'', text)
endglobal

# ====================Vimwiki/Markdown Snippets====================

snippet h1 "Header 1" b
# $1
$0
endsnippet

snippet h2 "Header 2" b
## $1
$0
endsnippet

snippet h3 "Header 3" b
### $1
$0
endsnippet

snippet h4 "Header 4" b
#### $1
$0
endsnippet

snippet h5 "Header 5" b
##### $1
$0
endsnippet

snippet h6 "Header 6" b
###### $1
$0
endsnippet

snippet tag "HTML tag <>" b
<$1>

${0:${VISUAL}}

</$1>
endsnippet

snippet itag "In-line HTML tag <>" w
<$1>${0:${VISUAL}}</$1>
endsnippet

snippet '(.+)?fen' "Fenced code block" rb
\`\`\``!p snip.rv = "" if match.group(1) == None else match.group(1)`
${0:${VISUAL}}
\`\`\`
endsnippet

snippet mcom "Markdown comment" b
[$1]: # $0
endsnippet

snippet hcom "Markdown comment" b
<!--- $1 --->$0
endsnippet

snippet br "Markdown breakline" w
<br>
endsnippet

snippet l "Simple link"
[${1:${VISUAL}}]($2)$0
endsnippet

snippet w "Web link"
[ðŸ“„ ${1:${VISUAL}}]($2)$0
endsnippet

snippet m "Markdown file link" w
[â†ª ${1:${VISUAL}}]($2)$0
endsnippet

snippet v "Video link" w
[ðŸ“º ${1:${VISUAL}}]($2)$0
endsnippet

snippet ve "YouTube Video link with embedded image" w
[ðŸ“º ${1:${VISUAL}}]($2)

[<img src="https://img.youtube.com/vi/${2/.*(watch\?v=|\/embed\/)([a-zA-Z0-9-_]*)((&|\/|)?.*)?/$2/}/0.jpg" alt="$1" width="auto"/>](https://www.youtube.com/embed/${2/.*(watch\?v=|\/embed\/)([a-zA-Z0-9-_]*)((&|\/|)?.*)?/$2//$1/} "$1")$0
endsnippet

snippet p "Video playlist link" w
[ðŸ’½ ${1:${VISUAL}}]($2)$0
endsnippet

snippet f "File Link" w
[â¬‡ ${1:${VISUAL}}](file:`!p snip.rv = get_wiki_files_dir()`$2)$0
endsnippet

snippet vf "vfile link" w
[â¬‡ ${1:${VISUAL}}](vfile:`!p snip.rv = get_wiki_files_dir()`$2)$0
endsnippet

snippet i "Image link" w
![${1:${VISUAL}}](`!p snip.rv = get_wiki_files_dir()`$2)$0
endsnippet

snippet ie "Clickable Image link" w
[![${1:${VISUAL}}](${2:path/to/image})](${3:redirect-link} "${4:Alt}")$0
endsnippet

snippet ih "HTML Image link" w
<a id="$1">
	<img data-enlargeable style="cursor: zoom-in"
	src="`!p snip.rv = get_wiki_files_dir()`$1.${2:png}"
	width="${3:auto}" alt="${4:alt}">
</a>

> $4
endsnippet

snippet '!\[(.*)\]\((.*)\)' "Convert image link to enlargeable image" r
<a id="`!p snip.rv = os.path.splitext(os.path.basename(match.group(2)))[0]`">
	<img data-enlargeable style="cursor: zoom-in"
	src="`!p snip.rv = match.group(2)`"
	width="${1:auto}" alt="`!p snip.rv = match.group(1)`">
</a>$0
endsnippet

snippet a "Markdown anchor link" w
[ðŸ“‘ ${1:${VISUAL}}](${2:file}#${1/(^[^a-zA-Z]+)?([a-zA-Z0-9.-]+)(\s*)/\L$2(?3:-)\E/g})$0
endsnippet

snippet '#(.*)&a' "Convert anchor name ref into valid html id" ir
`!p
ref = match.group(1)

ref = re.sub(r'^\d+\.*\s*', '', ref.lower())

# Transform special chars into uniformed separators
ref = ref.replace(' ', '-')
ref = ref.replace('_', '-')
ref = ref.replace('\`', '-')
ref = ref.replace('.', '-')
ref = ref.replace(',', '')
ref = ref.replace('\'', '')

snip.rv = '#' + ref
`
endsnippet

snippet pre "Html code block tag" w
<pre>
$0
</pre>
endsnippet

snippet kbd "Markdown key bindings tag" w
<kbd>${1:${VISUAL}}</kbd>$0
endsnippet

snippet < "Substitute markdown accepted literal character for '<'" i
&lt;
endsnippet

snippet > "Substitute markdown accepted literal character for '>'" i
&gt;
endsnippet

snippet * "Substitute markdown accepted literal character for '*'" i
&ast;
endsnippet

snippet -- "Long dash" i
â€”
endsnippet

snippet ** "Markdown Bold" i
**${1:${VISUAL}}**$0
endsnippet

snippet __ "Markdown Italic" i
_${1:${VISUAL}}_$0
endsnippet

snippet ~~ "Markdown Strikethrough" i
~~${1:${VISUAL}}~~$0
endsnippet

snippet hbo "Html bold tag" w
<b>${1:${VISUAL}}</b>$0
endsnippet

snippet hit "Html italic tag" w
<i>${1:${VISUAL}}</i>$0
endsnippet

snippet meta "Meta deta template" b
---
title: ${1:(INSERT TITLE)}
subtitle: ${2:(INSERT SUBTITLE)}
author: ${3:Mark Lucernas}
date: `date +'%b %d, %Y'`
---


$0
endsnippet

snippet temp "Vimwiki document template" b
---
title: ${1:(INSERT TITLE)}
subtitle: ${2:(INSERT SUBTITLE)}
author: ${3:Mark Lucernas}
date: `date +'%b %d, %Y'`
---


# $1: $2

$0


<br>

# Resources

endsnippet

snippet res "Vimwiki document resources header" b
<br>

# Resources

endsnippet

# Creates Todo list with Task Warrior.
# Prepend "!" to include weekly and monthly todos
# Prepend "@" to include overdue todos
# Prepend "&" to generate nested side todo templates
# Prepend "&&" to generate nested todo ONLY
post_jump "create_matrix_placeholders(snip)"
snippet '([!@&0-9]+)?td' "To-do list template" rb
`!p
# parse date filename
fn_date = fn.rstrip('.md')
fn_date = fn_date.split("-")
flags = match.group(1) if match.group(1) != None else ""

# Format date string
date_format = '%Y-%m-%d'
date_format_verbose = '%b %d, %Y'
default_due_time = 'T23:59:00'

base = datetime(int(fn_date[0]), int(fn_date[1]), int(fn_date[2]))
base_tomorrow = datetime(int(fn_date[0]), int(fn_date[1]), int(fn_date[2])) + timedelta(1)
base_yesterday = datetime(int(fn_date[0]), int(fn_date[1]), int(fn_date[2])) - timedelta(1)

today = datetime.strftime(base, date_format)
tomorrow = datetime.strftime(base_tomorrow, date_format)
yesterday = datetime.strftime(base_yesterday, date_format)

today_verbose = datetime.strftime(base, date_format_verbose)

end_of_today = today + default_due_time
end_of_tomorrow = tomorrow + default_due_time
end_of_yesterday = yesterday + default_due_time
end_of_week = (get_next_week_date(6, 1)).strftime(date_format) + default_due_time
end_of_next_week = (get_next_week_date(6, 2)).strftime(date_format) + default_due_time
end_of_last_week = (get_last_week_date(6, 2)).strftime(date_format) + default_due_time
end_of_month = get_last_day_of_month(base).strftime(date_format) + default_due_time

# Meta
title = f"title: TODO list"
subtitle = f"subtitle: {weekdays[str(base.weekday())]} to-do list. Managed by Taskwarrior and Taskwiki"
author = "author: Mark Lucernas"
date = f"date: {today_verbose}"
meta = f"---\n{title}\n{subtitle}\n{author}\n{date}\n---\n\n\n"

# Task warrior filters
proj = "proj:Todo"
# sched = f"sched:{today}"
due_today = f"due:{end_of_today}"
due_tomorrow = f"due:{end_of_tomorrow}"
due_yesterday = f"due:{end_of_yesterday}"
due_weekly = f"due:{end_of_week}"
due_monthly = f"due:{end_of_month}"
due_this_week = f"due.after:{end_of_yesterday} due.before:{end_of_week}"
due_next_week = f"due.after:{end_of_week} due.before:{end_of_next_week}"
due_last_week = f"due.after:{end_of_last_week} due.before:{end_of_yesterday}"
due_this_month = f"due.after:{end_of_yesterday} due.before:{end_of_month}"

result = ""
task_checkbox = "* [ ] "
separator = "--------------------------------------------------------------------------------\n\n"

# Main header
if "&&" not in flags:
	main_header = meta + "# Todo List || -VISIBLE " + proj + "\n"
	result += main_header + "\n"

# Overdue
if "@" in flags:
	overdue_task_header = "## ðŸ”¥ Overdue"
	overdue_task_filter = " | +OVERDUE"
	result += overdue_task_header
	result += overdue_task_filter + "\n\n"

# Append side task snippet into result if '&' flag was given
if "&" in flags:
	# Extract multiplier from flag if any
	mult = [int(c) for c in flags if c.isdigit()]
	mult = mult[0] if mult else 1

	for i in range(1, (mult * 3) + 1, 3):
		side_task_header = "## ${" + str(i) + ":Side}"
		side_task_filter = " | +${" + str(i) + "/(\w+)\s*/\L$1\E/g} +PENDING -OVERDUE priority:${" + str(i + 1) + ":H}" + " " + due_today
		result += side_task_header
		result += side_task_filter + "\n"
		result += task_checkbox + "$" + str(i + 2)
		# Single new line on last iteration if conditions are met
		if i <= (mult * 3) - 3:
			result += "\n\n"
		elif "&&" not in flags or "!" in flags or '@' in flags:
			result += "\n"

	result += "\n"

if "&&" not in flags:

	result += separator

	reminders_task_header = "## ðŸ”” Reminders"
	reminders_task_filter = " | +remind -COMPLETED priority:L"
	result += reminders_task_header
	result += reminders_task_filter + "\n\n"

	result += separator

	# Today
	today_task_header = "## ðŸƒ Today"
	today_task_filter = " | +PENDING -OVERDUE " + due_today
	result += today_task_header
	result += today_task_filter + "\n"
	result += task_checkbox + '$0' + "\n\n"

	# Next 14 days
	for i in range(1, 15):
		next_date = base + timedelta(i)
		next_day_task_header = "## ðŸŒ› " + weekdays[str(next_date.weekday())]
		next_day_task_filter = " | +PENDING -OVERDUE due:" + datetime.strftime(next_date, date_format) + default_due_time + "\n"
		result += next_day_task_header
		result += next_day_task_filter + "\n"

	# Someday task header
	someday_task_header = "## ðŸ”œ Someday"
	someday_task_filter = " | +someday wait:later -COMPLETED"
	result += someday_task_header
	result += someday_task_filter + "\n\n"

	result += separator

	# Weekly
	end_of_week_header = "## ðŸš¶ Weekly"
	end_of_week_filter = " | -OVERDUE +weekly " + due_weekly
	result += end_of_week_header
	result += end_of_week_filter + "\n\n"

	# This month
	end_of_month_header = "## ðŸ“† Monthly"
	end_of_month_filter = " | -OVERDUE +monthly " + due_monthly
	result += end_of_month_header
	result += end_of_month_filter + "\n\n"

	result += separator

	# weekly and monthly tasks
	if "!" in flags:
		# This week
		end_of_week_header = "## This Week"
		end_of_week_filter = " | -OVERDUE " + due_this_week
		result += end_of_week_header
		result += end_of_week_filter + "\n\n"

		# Next week
		end_of_next_week_header = "## Next Week"
		end_of_next_week_filter = " | -OVERDUE " + due_next_week
		result += end_of_next_week_header
		result += end_of_next_week_filter + "\n\n"

		# This month
		end_of_month_header = "## This Month"
		end_of_month_filter = " | -OVERDUE " + due_this_month
		result += end_of_month_header
		result += end_of_month_filter + "\n\n"

		result += separator

	# # Yesterday task header
	# yesterday_task_header = "## ðŸŒœ Yesterday"
	# yesterday_task_filter = " | -OVERDUE " + due_yesterday
	# result += yesterday_task_header
	# result += yesterday_task_filter + "\n\n"

	# Last week task header
	last_week_task_header = "## ðŸŒœ Last Week"
	last_week_task_filter = " | -OVERDUE " + due_last_week
	result += last_week_task_header
	result += last_week_task_filter + "\n\n"

# Output
snip.rv = result`
endsnippet

# Usage
# 16:30:30-16:40:30-10tt
# 16:30:30-16:40:30tt
# 16:59tt
post_jump "create_matrix_placeholders(snip)"
snippet '(([0-2]?[0-9]):([0-6][0-9])(:([0-5][0-9]))?)(-([0-2]?[0-9]):([0-5][0-9])(:([0-5][0-9]))?)?(-([0-9]+))?(h)?tt' "To-do list time template generator" rb
`!p
from_hrs = match.group(2) if match.group(2) != None else "00"
from_mins = match.group(3) if match.group(3) != None else "00"
from_secs = match.group(5) if match.group(5) != None else "00"
to_hrs = match.group(7) if match.group(7) != None else "00"
to_mins = match.group(8) if match.group(8) != None else "00"
to_secs = match.group(10) if match.group(10) != None else "00"
steps = int(match.group(12)) * 60 if match.group(12) != None else 1800
inherit_header = True if match.group(13) != None else False

time_format = "%H:%M:%S"
from_time = datetime.strptime(f"{from_hrs}:{from_mins}:{from_secs}", time_format)
to_time = datetime.strptime(f"{to_hrs}:{to_mins}:{to_secs}", time_format)
from_total_time_secs = sum(x * int(t) for x, t in zip([3600, 60, 1], f"{from_hrs}:{from_mins}:{from_secs}".split(":")))
to_total_time_secs = sum(x * int(t) for x, t in zip([3600, 60, 1], f"{to_hrs}:{to_mins}:{to_secs}".split(":")))

header_hash = "#"
header_name = ""
date = ""
result = ""

# Get parent header infos
parent_header = get_parent_header(snip)
filter_idx = parent_header.find('|') if parent_header.find('||') == -1 else -1
filters = parent_header[filter_idx:] if filter_idx != -1 else "|"
filters = filters.replace(' -SCHEDULED', '')

if parent_header != None:
	header_hash += parent_header[parent_header.find('#'):parent_header.find(' ')]
	if inherit_header:
		header_name = parent_header[parent_header.find(' '):parent_header.find('|') - 1]

# Get header due date, else filename
if parent_header.find('due:') != -1:
	idx = parent_header.find('due:')
	date = parent_header[idx + 4:parent_header.find('T', idx)]
else:
	fn_date = fn.rstrip('.md')
	date = fn_date.replace('-', ':')

if to_total_time_secs == 0:
	time_on = str(timedelta(seconds=from_total_time_secs))
	time_before = str(timedelta(seconds=from_total_time_secs + 60))
	time_after = str(timedelta(seconds=from_total_time_secs - 60))
	result += f"{header_hash}{header_name} {time_on} {filters} sched:{date}T{time_on} sched.before:{date}T{time_before} sched.after:{date}T{time_after}\n"
	result += "* [ ] $0"
else:
	while (from_total_time_secs <= to_total_time_secs):
		time_on = str(timedelta(seconds=from_total_time_secs))
		time_before = str(timedelta(seconds=from_total_time_secs + 60))
		time_after = str(timedelta(seconds=from_total_time_secs - 60))
		result += f"{header_hash}{header_name} {time_on} {filters} sched:{date}T{time_on} sched.before:{date}T{time_before} sched.after:{date}T{time_after}\n"
		from_total_time_secs += steps

# Output
snip.rv =  result`
endsnippet

snippet '(\d+)meds' "Description" rb
`!p
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
init_time = match.group(1)
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
today = datetime.strftime(base, '%Y-%m-%d')
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
`* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 600)`
* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 800)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 1600)`
* [ ] `!p snip.rv = create_meds_task("1 Aspirin EC 12hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("1 Aspirin EC 12hrs", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("2 Sennosides-docusate 2daily", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("2 Sennosides-docusate 2daily", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("1 Famotidine 1daily", init_time, 400)`
endsnippet

snippet due "Description" w
`!p
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
snip.rv = "(" + tomorrow + ")"`
endsnippet

snippet task "Todo/Task checkbox" bA
* [ ] $0
endsnippet

post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)([cC]{1,2})?t' "Markdown table (n)t" br
`!p
t_column_ct = int(match.group(1))
flags = match.group(2) if match.group(2) != None else ""

t_head = "| $0  "
t_sep = "|:-:" if 'C' in flags else "|---"
t_cell = "|   "

t_header = t_head + (t_cell * (t_column_ct - 1)) + "|"
t_sep = t_sep + (t_sep * (t_column_ct - 1)) + "|"
t_body = t_cell + (t_cell * (t_column_ct - 1)) + "|"

result = t_header + "\n" + t_sep + "\n" + t_body

if 'c' in flags:
	result = "<center>\n\n" + result + "\n\n</center>\n"

snip.rv = result
`
endsnippet

# Usage: [wrap]?table, optional wrapper char for each table cell
# Note: Lines should trail '&' char for splitting. Only until second to last.
# Ref: http://vimcasts.org/episodes/ultisnips-visual-placeholder/
snippet '([`$_*])?([cC]{1,2})?atab' "Markdown Table Builder" rb
`!p
# Fetch visual selected text
wrap_char =  match.group(1) if match.group(1) != None else "" # Wraper char to wrap table cell items
flags = match.group(2) if match.group(2) != None else ""
text = snip.v.text

if match.group(1) != None:
	if wrap_char == '$': # '\\' to escape '$' wrap char
		wrap = "\\" + wrap_char
	elif wrap_char == '*':
		wrap = "**"
	else:
		wrap = wrap_char
else:
	wrap = ""

delim = "\t" # Delimeter
lines = text.split("\n") # Split lines delimited by new line
result = "" # String container to be returned
line_count = 0
for line in lines[:-1]: # Loop over lines
	line_tmp = ""
	separator = ""
	line = line.split(delim) # Split all items in line
	for item in line: # Loop over items in lines
		# Strip leading and trailing whitespaces
		item = item.lstrip().rstrip()

		if line_count == 0:
			line_tmp += "| " + item + " " # Format without wrap and append item to line
			if 'C' in flags:
				separator += "|:" + ("-" * (len(item))) + ":" # Centered table contents
			else:
				separator += "|" + ("-" * (len(item) + 2))

		if line_count >= 1:
			line_tmp += "| " + wrap + item + wrap + " " # Format with wrap and append item to line

	result += line_tmp + "|\n" # Append new line and close table row

	if line_count == 0: # Table header and body separator
		result += separator + "|\n"

	line_count += 1

if 'c' in flags:
	result = "<center>\n\n" + result + "\n</center>\n"

snip.rv = result
`
endsnippet

snippet tab2 "Two tables side by side" b
<center>

<table>
%% Table Headings are OPTIONAL
<tr><th>${1:Table Heading 1}</th><th>${2:Table Heading 2}</th></tr>
<tr><td>

%% Insert first table HERE

</td><td>

%% Insert second table HERE

</td></tr>
</table>

</center>
endsnippet

snippet tab3 "Three tables side by side" b
<center>

<table>
%% Table Headings are OPTIONAL
<tr><th>${1:Table Heading 1}</th><th>${2:Table Heading 2}</th><th>${3:Table Heading 3}</th></tr>
<tr><td>

%% Insert first table HERE

</td><td>

%% Insert second table HERE

</td><td>

%% Insert Third table HERE

</td></tr>
</table>

</center>
endsnippet

snippet TM "Markdown trademark symbol" i
&trade;
endsnippet

snippet R "Markdown registered symbol" i
&reg;
endsnippet

snippet C "Markdown copyright symbol" i
&copy;
endsnippet

# ==========Note taking snippets========== #
snippet tstamp "Video lecture timestamps" b
Timestamps

	$0
endsnippet

snippet ttime "Video lecture timestamp item" i
- ${1:title} ${2:1:00}
endsnippet

# Usage: <youtube-url>&e<tab>
post_jump "create_matrix_placeholders(snip)"
snippet '((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))&e' "YouTube pseudo embedded video" wr
`!p
home_url = match.group(1)
http_url = match.group(2)
www_url = match.group(3)
domain_url = match.group(4)
video_url = match.group(5)
video_mode = match.group(6)
video_id = match.group(7)
link = "https://www.youtube.com"

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# snip.rv = "[![${1:Alt text}](https://img.youtube.com/vi/" + video_id + "/2.jpg)](" + link + "${1/.*/ \"$0\"/})$0"
snip.rv = "[<img src=\"https://img.youtube.com/vi/" + video_id + "/0.jpg\" alt=\"${1:Alt text}\" width=\"auto\"/>](" + link + "${1/.*/ \"$0\"/})$0"
`
endsnippet

# Usage: (00:00:00 or 00:00)<youtube-url>&t<tab>
snippet '((\d{1,2}:)?(\d{1,2}):(\d{2}))((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))&t' "YouTube url with time stamp" wrA
[(`!p snip.rv = match.group(1)`)](`!p
# check if hours exist
hours = match.group(2)
if hours:
	hours = int(hours).rstrip(":")
else:
	hours = 0

minutes = int(match.group(3))
seconds = int(match.group(4))
home_url = match.group(5)
http_url = match.group(6)
www_url = match.group(7)
domain_url = match.group(8)
video_url = match.group(9)
video_mode = match.group(10)
video_id = match.group(11)
link = "https://www.youtube.com"

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# convert timestamp to seconds then append to link
snip.rv = link + "&t=" + str((hours * 60) + (minutes * 60) + seconds)
`)
endsnippet

# Usage: <youtube-url>&y<tab>
post_jump "create_matrix_placeholders(snip)"
snippet '(\()?((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))&y' "Clean and create Youtube link" wr
`!p
home_url = match.group(2)
http_url = match.group(3)
www_url = match.group(4)
domain_url = match.group(5)
video_url = match.group(6)
video_mode = match.group(7)
video_id = match.group(8)
link = "https://www.youtube.com"

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# If inside markdown link wrapper, don't wrap, else, wrap it.
if match.group(1):
  snip.rv = match.group(1) + link
else:
	snip.rv = "[ðŸ“º $1](" + link + ")$0"
`
endsnippet

# Usage: [<desc>](<youtube-link>)<tab>
post_jump "create_matrix_placeholders(snip)"
snippet '(-\ )?\[(.*)\]\((\()?((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))\)' "Convert md youtube link to pseudo embedded youtube video link" wr
`!p
# Strip emojis, leading and trailing whitespaces
desc = match.group(2)
home_url = match.group(4)
http_url = match.group(5)
www_url = match.group(6)
domain_url = match.group(7)
video_url = match.group(8)
video_mode = match.group(9)
video_id = match.group(10)
link = "https://www.youtube.com"

desc_clean = strip_emojis(desc).strip()

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

snip.rv =  "- [" + desc + "](" + link + ")\n\n" + "[<img src=\"https://img.youtube.com/vi/" + video_id + "/0.jpg\" alt=\"" + desc_clean + "\" width=\"${1:auto}\"/>](" + link + " \"" + desc_clean + "\")$0" `
endsnippet

# Usage: &name-of-link&alink
snippet '&?([A-Za-z- ]+)\&(t)?alink' "Word or pharse definition auto" wr
[`!p
snip.rv = match.group(1).replace("-", " ")
`]($1#${2:`!p
		snip.rv = match.group(1).replace(" ", "-").lower() if match.group(2) == None else match.group(1).replace(" ", "-").lower() + "-term"
`})$0
endsnippet

# USAGE
# Termininology name&iterm
# **Terminology name**&term
# **terminology name**&iterm
#
# In-line flag:
# &terminology name&term -- in-line definition
# terminology name&iterm -- same line definition
#
# Abbreviation flag:
# terminology name&aterm
# &terminology name&aterm
#
# Capitalization flags:
# terminology name&cterm -- capitalize
# &terminology name&tterm -- titlelize
#
# Mixed flags:
# terminology name&iaterm -- same line definition with abbrev
# terminology name&iacterm -- capitalized same line definition with abbrev
# a, i, c or t flags are interchangeable
post_jump "create_matrix_placeholders(snip)"
snippet '(&)?(\*\*)?([^.*\[\]#&]+)(\*\*)?&([ia(t|c)]{1,3})?term$' "Word or phrase definition auto" wr
`!p
orig_term = match.group(3).lstrip().rstrip()
flags = match.group(5)
text = ""
copy = True
# Check if theres parenthesis and exclude its contents from anchor link
parenthesis = set('()')
if any((c in parenthesis) for c in orig_term):
	for i in range(0, len(orig_term) - 1):
		if ((orig_term[i] == "(" or orig_term[i + 1] == "(") and copy == True):
			copy = False
			continue
		elif (orig_term[i] == ")" and copy == False):
			copy = True
			continue

		if copy == True:
			text += orig_term[i]
else:
  text = orig_term

# Anchor link with '-term' appended to name
anchor = "<a id=\"" + text.replace("'", "").replace(" ", "-").lower() + "-term\">"
# Flags
if flags:
	# Abbreviation
	if 'a' in flags:
		# Credits: https://stackoverflow.com/a/41191867/11850077
		abbrev = (" (" + ''.join([s[0] for s in orig_term.split()]).upper() + ")")
	else:
		abbrev = ""
	# In-line
	if match.group(1):	# In-line definition. If term sandwhiched by '&'
		end = "$0"
	elif 'i' in flags:				# Same line definition
		end = ": $0<br>"
	else:
		end = "\n\n:   $0"				# Multi-line definition
	# Capitalizations
	if 'c' in flags:					# Capitalize term
		term = orig_term.capitalize()
	elif 't' in flags:				# Titlelize term
		term = orig_term.title()
	else:
		term = orig_term
else:
	abbrev = ""
	if match.group(1):	# In-line definition. If term sandwhiched by '&'
		end = "$0"
	else:
		end = "\n\n:   $0"
	term = orig_term

snip.rv = anchor + "**" + term + abbrev + "**</a>" + end`
endsnippet

snippet aterm "Markdown term anchor link" w
[${1:${VISUAL}}](${2:`!p snip.rv = get_nearest_glossary()`}#${1/(^[^a-zA-Z]+)?([a-zA-Z0-9.-]+)(\s*)/\L$2(?3:-)\E/g}-term)$0
endsnippet

# ====================LaTeX/Mathjax Snippets==================== #

context "math()"
snippet '(?<!\\|\)|\])\$([0-9]+,[0-9]+(\.[0-9]+)?)\s(?!\$)' "LaTeX auto currency" rwA
`!p snip.rv = "\$" + match.group(1) + " "`
endsnippet

# Symbols (Relations)
# ============================================================

context "math()"
snippet <= "LaTeX less than or equals to" iA
\leq
endsnippet

context "math()"
snippet >= "LaTeX greater than or equals to" iA
\geq
endsnippet

context "math()"
snippet >> "LaTeX much greater than" iA
\gg
endsnippet

context "math()"
snippet << "LaTeX muchn less than" iA
\ll
endsnippet

context "math()"
snippet != "LaTeX not equals to" iA
\neq
endsnippet

context "math()"
snippet ~~ "LaTeX approximation symbol" iA
\approx
endsnippet

context "math()"
snippet ~= "LaTeX congruent symbol" iA
\cong
endsnippet

context "math()"
snippet -= "LaTeX equivalent symbol" iA
\equiv
endsnippet

context "math()"
snippet => "LaTeX implies symbol" iA
\implies
endsnippet

context "math()"
snippet =< "LaTeX implied by symbol" iA
\impliedby
endsnippet

context "math()"
snippet def= "Latex define equal symbol" iA
\overset{\underset{\mathrm{${1:def}}}{}}{${2:=}}$0
endsnippet

context "math()"
snippet ~ "Latex symmetrical symbol" i
\sim
endsnippet

context "math()"
snippet ~= "Latex symmetrical equals symbol" i
\simeq
endsnippet

context "math()"
snippet prop "LaTeX proportional to symbol" iA
\propto
endsnippet

context "math()"
snippet 'iff' "LaTeX if and only if symbol" iA
\iff
endsnippet

context "math()"
snippet sub "Latex proper subset symbol" iA
\subset
endsnippet

context "math()"
snippet nsub "Latex not a proper subset symbol" iA
\not\subset
endsnippet

context "math()"
snippet subeq "Latex subset symbol" iA
\subseteq
endsnippet

context "math()"
snippet nsubeq "Latex not a subset symbol" iA
\not\subseteq
endsnippet

context "math()"
snippet sup "Latex superset symbol" iA
\superset
endsnippet

context "math()"
snippet nsup "Latex not a superset symbol" iA
\not\superset
endsnippet

context "math()"
snippet !0 "Latex emptyset symbol" iA
\emptyset
endsnippet

context "math()"
snippet in "Latex in symbol" w
\in
endsnippet

context "math()"
snippet !in "Latex not in symbol" w
\not\in
endsnippet

context "math()"
snippet ni "Latex in reverse symbol" w
\ni
endsnippet

context "math()"
snippet !in "Latex not in reverse symbol" w
\not\ni
endsnippet

# Exponents, Superscript, Subscript
# ============================================================

# Auto exponent/superscript
# Matches ^ followed by pattern of characters using negative lookbehind

context "math()"
snippet '((?<=[a-zA-Z0-9]|\)|\}|\]|\|)|(?<=sin|cos|tan|csc|sec|cot))\^' "LaTeX auto exponent/superscript" irA
^{$1}$0
endsnippet

context "math()"
snippet '((?<=[a-zA-Z0-9]|\)|\}|\]|\|)|(?<=sin|cos|tan|csc|sec|cot))_' "LaTeX auto subscript" irA
_{$1}$0
endsnippet

snippet _ "LaTeX subscript" i
_{$1}$0
endsnippet

snippet ^ "LaTeX superscript" i
^{$1}$0
endsnippet

# Math
# ============================================================

# Usage:
# f// -> \frac{$1}{$2}$0
# df// -> \dfrac{$1}{$2}$0
# tf// -> \tfrac{$1}{$2}$0
context "math()"
snippet '(d|t)?f//' "LaTeX normal/display/textstyle fraction" riA
`!p
snip.rv = "\\" if match.group(1) == None else "\\" + match.group(1)
`frac{${1:${VISUAL}}}{$2}$0
endsnippet

# Usage:
# b// -> \binom{$1}{$2}$0
context "math()"
snippet b// "LaTeX symbol binomial coefficient" iA
\binom{${1:${VISUAL}}}{$2}$0
endsnippet

# Usage:
# abc/f/ -> \frac{abc}{$0}
# (abc)/f/ -> \frac{abc}{$0}
context "math()"
snippet '(\()?(.*)(\))?/f/' "LaTeX () auto fraction" wrA
\frac{`!p snip.rv = match.group(2)`}{$0}
endsnippet

# Usage:
# abc/b/ -> \binom{abc}{$0}
# (abc)/b/ -> \binom{abc}{$0}
context "math()"
snippet '(\()?(.*)(\))?/b/' "LaTeX () auto binomial" wrA
\binom{`!p snip.rv = match.group(2)`}{$0}
endsnippet

context "math()"
snippet sqrt "LaTeX square root" iA
\sqrt{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet '(\d+|n|x|y|z)root' "LaTeX root of n" irA
\sqrt[`!p snip.rv = match.group(1)`]{$1}$0
endsnippet

# Logarthmic function
context "math()"
snippet '(log|ln)([a-zA-Z0-9]{1,5})?' "LaTeX Logarithmic function" ir
`!p
log = match.group(1)
base = "_{" + match.group(2) + "}" if match.group(2) else ""
snip.rv = "\\" + log + base`($1)$0
endsnippet

context "math()"
snippet inf "LaTeX infinity" iA
\infty
endsnippet

context "math()"
snippet VV "Latex large intersection" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet UU "Latex large union" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet 'setm' "Latex set minus" iA
\setminus
endsnippet

context "math()"
snippet comp "LaTeX complement" iA
^{c}
endsnippet

context "math()"
snippet inv "LaTeX inverse" iA
^{-1}
endsnippet

context "math()"
snippet ang "LaTeX angle symbol" iA
\angle{$1}$0
endsnippet

context "math()"
snippet int "Latex integration" wA
\int${1:_{${2:-\infty}}^{${3:\infty}}} ${4:${5:f(x)}\;dx}$0
endsnippet

context "math()"
snippet dint "LaTeX displaystyle integral" wA
{\displaystyle \int${1:_{${2:-\infty}}^{${3:\infty}}} ${4:${5:f(x)}\;dx}}$0
endsnippet

context "math()"
snippet sum "LaTeX summation" wA
\sum${1:_{${2:i} = ${3:1}}^{${4:n}}} ${5:${6:f(${7:x_{i}})}\;${8:\Delta{x}}}$0
endsnippet

context "math()"
snippet lim "Latex limit" iA
\lim${1:_{${2:n} \to ${3:\infty}}} ${4:${5:f(x)} = ${6:x}}$0
endsnippet

context "math()"
snippet reim "LaTeX Reiman sum" wA
\lim_{${1:n} \to ${2:\infty}} \sum_{${3:i} = ${3:1}}^{${4:n}} ${5:${6:f(${7:x_{i}})}${8:\Delta{x}}}$0
endsnippet

context "math()"
snippet lims "Latex limit superior" wA
\limsup_{${1:n} \to ${2:\infty}}
endsnippet

context "math()"
snippet prod "Latex product" wA
\prod${1:_{${2:n=${3:1}}}^{${4:\infty}}} ${5:${VISUAL}}$0
endsnippet

context "math()"
snippet pder "Latex partial derivative" wA
\frac{\partial ${1:V}}{\partial ${2:x}}$0
endsnippet

context "math()"
snippet der "Latex derivative" wA
\frac{d${1:V}}{d${2:x}}$0
endsnippet

context "math()"
snippet _} "LaTeX underbrace" iA
\underbrace{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet ^} "LaTeX overbrace" iA
\overbrace{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet PP "LaTeX prime numbers" iA
\mathbb{P}
endsnippet

context "math()"
snippet NN "LaTeX natural numbers" iA
\mathbb{N}
endsnippet

context "math()"
snippet ZZ "LaTeX integer numbers" iA
\mathbb{Z}
endsnippet

context "math()"
snippet WW "LaTeX whole numbers" iA
\mathbb{W}
endsnippet

context "math()"
snippet II "LaTeX irrational numbers" iA
\mathbb{I}
endsnippet

context "math()"
snippet QQ "LaTeX rational numbers" iA
\mathbb{Q}
endsnippet

context "math()"
snippet RR "LaTeX real numbers" iA
\mathbb{R}
endsnippet

context "math()"
snippet CC "LaTeX complex numbers" iA
\mathbb{C}
endsnippet

context "math()"
snippet SS "LaTeX section" iA
\S
endsnippet

context "math()"
snippet iE "LaTeX exists" iA
\exists
endsnippet

context "math()"
snippet iA "LaTeX forall" iA
\forall
endsnippet

context "math()"
snippet xx "LaTeX cross" iA
\times
endsnippet

context "math()"
snippet tf "LaTeX therefore symbol" iA
\therefore
endsnippet

context "math()"
snippet bc "LaTeX because symbol" iA
\because
endsnippet

context "math()"
snippet to "to" iA
\to
endsnippet

context "math()"
snippet mto "mapsto" iA
\mapsto
endsnippet

context "math()"
snippet c. "LaTeX cdot" iA
\cdot
endsnippet

context "math()"
snippet .c "LaTeX center dots" iA
\cdots
endsnippet

context "math()"
snippet .l "LaTeX lower dots" iA
\ldots
endsnippet

context "math()"
snippet .v "LaTeX vertical dots" iA
\vdots
endsnippet

context "math()"
snippet .d "LaTeX diagonal dots" iA
\ddots
endsnippet

context "math()"
snippet ' "LaTeX prime" i
^{\prime}
endsnippet

context "math()"
snippet '' "LaTeX double prime" i
^{\prime \prime}
endsnippet

context "math()"
snippet vec "LaTeX vector" iA
\vec{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet 'det' "LaTeX determinant" iA
\det $0
endsnippet

context "math()"
snippet mag "LaTeX vector's magnitude" iA
\\|${1:${VISUAL}}\\|$0
endsnippet

context "math()"
snippet hat "LaTeX hat" iA
\hat{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet || "LaTeX parallel sign" i
\parallel
endsnippet

context "math()"
snippet | "LaTeX mid sign" i
\mid
endsnippet

context "math()"
snippet n| "LaTeX not mid sign" i
\nmid
endsnippet

context "math()"
snippet '(\d+)?(a)?((sin|cos|tan|csc|sec|cot)h?)(\d+[a-zA-Z0-9]*|[a-zA-Z]+|-)?' "LaTeX trig functions" wrA
`!p
# Constants
mult = "" if match.group(1) == None else match.group(1)
# Arc functions
if match.group(2) == 'a':
	arc = "arc"
else:
	arc = ""
# Apply sech and csch workaround to trig function
if (match.group(3) == "sech" or match.group(3) == "csch"):
	trig = "operatorname{" + match.group(3) + "}"
else:
	trig = match.group(3)
# Negative functions
if match.group(5) == None:
	expo = ""
elif match.group(5) == "-":
	expo = "^{-1}"
else:
	expo = "^{" + match.group(5) + "}"

snip.rv = mult + "\\" + arc + trig + expo
`($1)$0
endsnippet

# Symbols (Arrows)
# ============================================================

context "math()"
snippet Ua "LaTeX double lined uparrow" i
\Uparrow
endsnippet

context "math()"
snippet Da "LaTeX double lined downarrow" i
\Downarrow
endsnippet

context "math()"
snippet Uda "LaTeX double lined updownarrow" i
\Updownarrow
endsnippet

context "math()"
snippet La "LaTeX double lined leftarrow" i
\Leftarrow
endsnippet

context "math()"
snippet Ra "LaTeX double lined rightarrow" i
\Rightarrow
endsnippet

context "math()"
snippet Lra "LaTeX double lined leftrightarrow" i
\Leftrightarrow
endsnippet

context "math()"
snippet Lal "LaTeX double lined long leftarrow" i
\Longleftarrow
endsnippet

context "math()"
snippet Ral "LaTeX double lined long rightarrow" i
\Longrightarrow
endsnippet

context "math()"
snippet Lral "LaTeX double lined long leftrightarrow" i
\Longleftrightarrow
endsnippet

context "math()"
snippet da "LaTeX single lined downarrow" i
\downarrow
endsnippet

context "math()"
snippet uda "LaTeX single lined updownarrow" i
\updownarrow
endsnippet

context "math()"
snippet la "LaTeX single lined leftarrow" i
\leftarrow
endsnippet

context "math()"
snippet ra "LaTeX single lined rightarrow" i
\rightarrow
endsnippet

context "math()"
snippet lra "LaTeX single lined leftrightarrow" i
\leftrightarrow
endsnippet

context "math()"
snippet lal "LaTeX long single lined leftarrow" i
\longleftarrow
endsnippet

context "math()"
snippet ral "LaTeX long single lined rightarrow" i
\longrightarrow
endsnippet

context "math()"
snippet lral "LaTeX long single lined leftrightarrow" i
\Longleftrightarrow
endsnippet

context "math()"
snippet ^la "LaTeX overset left arrow" i
\overset{$1}\leftarrow$0
endsnippet

context "math()"
snippet _la "LaTeX underset left arrow" i
\underset{$1}\leftarrow$0
endsnippet

context "math()"
snippet ^ra "LaTeX overset right arrow" i
\overset{$1}\rightarrow$0
endsnippet

context "math()"
snippet _ra "LaTeX underset right arrow" i
\underset{$1}\rightarrow$0
endsnippet

# Symbols (Logic)
# ============================================================

context "math()"
snippet '(?<=[a-zA-Z0-9])cir' "LaTeX auto degrees symbol" irA
^{\circ}
endsnippet

context "math()"
snippet cir "LaTeX degrees symbol" i
\circ
endsnippet

context "math()"
snippet vv "Latex intersection symbol" iA
\cap
endsnippet

context "math()"
snippet uu "Latex union symbol" iA
\cup
endsnippet

# Symbols (Misc)
# ============================================================

context "math()"
snippet '(\+-|-\+)' "LaTeX plus minus sign" irA
\pm
endsnippet

context "math()"
snippet nab "Latex inverted delta greek symbol" i
\nabla
endsnippet

context "math()"
snippet suitc "LaTeX club suit symbol" i
\clubsuit
endsnippet

context "math()"
snippet suith "LaTeX heart suit symbol" i
\heartsuit
endsnippet

context "math()"
snippet suits "LaTeX spade suit symbol" i
\spadesuit
endsnippet

context "math()"
snippet suitd "LaTeX diamond suit symbol" i
\diamondsuit
endsnippet

# Symbols (Greek)
# ============================================================

context "math()"
snippet alp "LaTeX alpha symbol" i
\alpha
endsnippet

context "math()"
snippet bet "LaTeX beta symbol" i
\beta
endsnippet

context "math()"
snippet del "LaTeX delta symbol" i
\delta
endsnippet

context "math()"
snippet eps "LaTeX epsilon symbol" i
\epsilon
endsnippet

context "math()"
snippet vep "LaTeX varepsilon symbol" i
\varepsilon
endsnippet

context "math()"
snippet zet "LaTeX zeta symbol" i
\zeta
endsnippet

context "math()"
snippet eta "LaTeX eta symbol" i
\eta
endsnippet

context "math()"
snippet the "LaTeX theta symbol" i
\theta
endsnippet

context "math()"
snippet vth "LaTeX vartheta symbol" i
\vartheta
endsnippet

context "math()"
snippet gam "LaTeX gamma symbol" i
\gamma
endsnippet

context "math()"
snippet kap "LaTeX gamma symbol" i
\kappa
endsnippet

context "math()"
snippet lam "LaTeX lambda symbol" i
\lambda
endsnippet

context "math()"
snippet xi "LaTeX xi greek symbol" i
\xi
endsnippet

context "math()"
snippet mu "LaTeX mu greek symbol" i
\mu
endsnippet

context "math()"
snippet nu "LaTeX nu greek symbol" i
\nu
endsnippet

context "math()"
snippet pi "LaTeX pi greek symbol" i
\pi
endsnippet

context "math()"
snippet vpi "LaTeX varpi greek symbol" i
\varpi
endsnippet

context "math()"
snippet rho "LaTeX rho greek symbol" i
\rho
endsnippet

context "math()"
snippet vrh "LaTeX phi greek symbol" i
\varrho
endsnippet

context "math()"
snippet sig "LaTeX sigma greek symbol" i
\sigma
endsnippet

context "math()"
snippet vsi "LaTeX varsigma greek symbol" i
\varsigma
endsnippet

context "math()"
snippet tau "LaTeX tau greek symbol" i
\tau
endsnippet

context "math()"
snippet ups "LaTeX upsilon greek symbol" i
\upsilon
endsnippet

context "math()"
snippet phi "LaTeX phi greek symbol" i
\phi
endsnippet

context "math()"
snippet vph "LaTeX varphi greek symbol" i
\varphi
endsnippet

context "math()"
snippet chi "LaTeX chi greek symbol" i
\chi
endsnippet

context "math()"
snippet psi "LaTeX psi greek symbol" i
\psi
endsnippet

context "math()"
snippet ome "LaTeX omega greek symbol" i
\omega
endsnippet

context "math()"
snippet Gam "LaTeX Gamma greek symbol" i
\Gamma
endsnippet

context "math()"
snippet Del "LaTeX Delta greek symbol" i
\Delta
endsnippet

context "math()"
snippet The "LaTeX Theta greek symbol" i
\Theta
endsnippet

context "math()"
snippet Lam "LaTeX Lambda greek symbol" i
\Lambda
endsnippet

context "math()"
snippet Xi "LaTeX Xi greek symbol" i
\Xi
endsnippet

context "math()"
snippet Pi "LaTeX Pi greek symbol" i
\Pi
endsnippet

context "math()"
snippet Sig "LaTeX Sigma greek symbol" i
\Sigma
endsnippet

context "math()"
snippet Ups "LaTeX Upsilon greek symbol" i
\Upsilon
endsnippet

context "math()"
snippet Phi "LaTeX Phi greek symbol" i
\Phi
endsnippet

context "math()"
snippet Psi "LaTeX Psi greek symbol" i
\Psi
endsnippet

context "math()"
snippet Ome "LaTeX Omega greek symbol" i
\Omega
endsnippet

# Syntax
# ============================================================

context "math()"
snippet '(\\|!)!' "LaTex small negative spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\!\\!'
elif prefix == '!':
	snip.rv = '\\!'
`
endsnippet

context "math()"
snippet '(\\|,),' "LaTex small spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\,\\,'
elif prefix == ',':
	snip.rv = '\\,'
`
endsnippet

context "math()"
snippet '(\\|:):' "LaTex medium spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\:\\:'
elif prefix == ':':
	snip.rv = '\\:'
`
endsnippet

context "math()"
snippet '(\\|;);' "LaTex large spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\;\\;'
elif prefix == ';':
	snip.rv = '\\;'
`
endsnippet

context "math()"
snippet diss "LaTeX Display mode" i
{\displaystyle ${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet texs "LaTeX Text mode" i
{\textstyle ${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet scrs "LaTeX Script mode" i
{\scriptstyle ${1:${VISUAL}}}$0
endsnippet

snippet xtt "LaTeX text" iA
\text{${1:${VISUAL}}}$0
endsnippet

snippet xtbo "LaTeX text bold" iA
\textbf{${1:${VISUAL}}}$0
endsnippet

snippet xtit "LaTeX text italic" iA
\textit{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet xsbo "LaTeX symbol bold" iA
\boldsymbol{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet xmbo "LaTeX math bold" iA
\mathbf{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet xmit "LaTeX math italic" iA
\mathit{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet xmca "LaTeX mathcal" iA
\mathcal{$1}$0
endsnippet

context "math()"
snippet xmbb "LaTeX mathbb" iA
\mathbb{$1}$0
endsnippet

context "math()"
snippet pha "LaTeX phantom placeholder" i
\phantom{$1}$0
endsnippet

context "math()"
snippet npha "LaTeX negative phantom placeholder" i
\phantom{-}$0
endsnippet

context "math()"
snippet xsol "LaTeX overline" iA
\overline{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet xsul "LaTeX underline" iA
\underline{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet cout "LaTeX Cancel out" w
\cancel{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet col "LaTeX text color" w
{\color{#${1:ff0000}}{${2:${VISUAL}}}}$0
endsnippet

context "math()"
snippet coc "Cancel out with color" w
{\color{#${1:ff0000}}{\cancel{{\color{#${1:000000}}{${3:${VISUAL}}}}}}}$0
endsnippet

context "math()"
snippet nl "LaTeX empty line" bA
~\\\\
endsnippet

context "math()"
snippet begin "LaTeX begin function" bA
\begin{$1}
	${0:${VISUAL}}
\end{$1}
endsnippet

context "math()"
snippet bmat "LaTeX in-line brackets matrix" wbA
\begin{bmatrix} ${1:${VISUAL}} \end{bmatrix}$0
endsnippet

context "math()"
snippet Bmat "LaTeX in-line curly braces matrix" wbA
\begin{Bmatrix} ${1:${VISUAL}} \end{Bmatrix}$0
endsnippet

context "math()"
snippet pmat "LaTeX in-line parenthesis matrix" wbA
\begin{pmatrix} ${1:${VISUAL}} \end{pmatrix}$0
endsnippet

context "math()"
snippet vmat "LaTeX in-line determinant matrix" wbA
\begin{vmatrix} ${1:${VISUAL}} \end{vmatrix}$0
endsnippet

context "math()"
snippet Vmat "LaTeX in-line double absolute values matrix" wbA
\begin{Vmatrix} ${1:${VISUAL}} \end{Vmatrix}$0
endsnippet

# Usage: arr[#column],[#row] ->
# \begin{array}{#column}
#   &*[column*row] \\
# \end{array}
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+),(\d+)ar' "LaTeX array" rbA
\begin{array}{`!p
orient = ""
for _ in range(0, int(match.group(1))): orient += "l"
snip.rv = orient`}
`!p
snip.rv = create_matrix(match.group(1), match.group(2), " & ", "\t", " \\\\\\\\\n")
`$0
\end{array}
endsnippet

# Usage: [#column]== ->
# \begin{aligned}
#   &= \\ *[#columng]
# \end{array}
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)eq' "LaTeX block align equations" rbA
\begin{aligned}
`!p
snip.rv = create_matrix(2, match.group(1), " &= ","\t", " \\\\\\\\\n")
`
\end{aligned}$0
endsnippet

# Usage: [#column]pw ->
# \begin{aligned}
#   , & , \\ *[#column]
# \end{array}
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)pw' "LaTeX piecewise" rbA
\left\\\\{\begin{array}{ll}
`!p
snip.rv = create_matrix(2, match.group(1), ", & ","\t", " \\\\\\\\\n")
`
\end{array}\right.$0
endsnippet

# Usage: "i((l or r)or(b))n,nm", where `i` (optional) is the in-line trigger
# either `l or r` (optional) as separators, `b` (optional) as the boundary type
# , and `n,n` as the matrix size (rows, column). No spaces and ignore
# parenthesis, and can't have both separators and boundary together.
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '\b(i)?(((l)?(r)?)(b|B|v|V|p?))(\d+),(\d+)(m)?' "LaTeX matrix" wr
`!p
inline = match.group(1)
left = match.group(4) # left matrix separator
right = match.group(5) # right matrix separator
boundary = match.group(6) # boundary type

# Determine if in-line or block
indent = ""
if inline:
	inline = " "
else:
	inline = "\n"
	indent = "\t"

right_bound = "|" if match.group(9) == "m" else "."
if left or right:
	# Left boundary with right separator. Default boundary is "|"
	if left and right == None:
		if boundary:
			left = "\\left" + boundaries[f"{boundary}"][0]
			right = "\\right" + right_bound
		else:
			left = "\\left|"
			right = "\\right" + right_bound
	# Right boundary only
	elif left == None and right:
		if boundary:
			left = "\\left."
			right = "\\right" + boundaries[f"{boundary}"][1]
		else:
			left = "\\left."
			right = "\\right" + right_bound
	# Left and right separator
	elif left and right:
		if boundary:
			left = "\\left" + boundaries[f"{boundary}"][0]
			right = "\\right" + boundaries[f"{boundary}"][1]
		else:
			left = "\\left|"
			right = "\\right" + right_bound
	# Remove boundary
	boundary = ""
elif boundary:
	# No separator
	left = ""
	right = ""
else:
	# No boundary and separator
	left = ""
	right = ""
	boundary = ""
# Matrix size
rows = match.group(7)
cols = match.group(8)
# LaTeX matrix wrapper
begin = left + "\\begin{" + boundary + "matrix}" + inline
end = inline + "\\end{" + boundary + "matrix}" + right
result = "" # result value
placeholder = 1 # placeholder number for snippet jumps

# Matrix entries
result += create_matrix(rows, cols, " & ", indent, " \\\\\\\\" + inline)
snip.rv = begin + result + end
`$0
endsnippet

# Usage:
# item<tab> ->
# item
# item
context "math()"
context "env('itemize')"
snippet '(?<=\\item)(.+)' "LaTeX item" r
`!p snip.rv = match.group(1)`
\\item $0
endsnippet

# Usage:
# item<tab> ->
# item
# item
context "math()"
context "env('enumerate')"
snippet '(?<=\\item)(.+)' "LaTeX item" r
`!p snip.rv = match.group(1)`
\\item $0
endsnippet

# Usage:
# item<tab> ->
# item
# item
context "math()"
context "env('description')"
snippet '(?<=\\item)(.+)' "LaTeX item" r
`!p snip.rv = match.group(1)`
\\item $0
endsnippet

# Usage:
# [number]item
# \begin{itemize}
#   item*[number]
# \end{itemiz}
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)item' "LaTeX itemize" brA
\begin{itemize}
`!p
res = "\t\\item $1"
if match.group(1):
	res = create_matrix(1, match.group(1), "", "\t\\item ", "\n")
	snip.rv = res
`
\end{itemize}$0
endsnippet

# Usage:
# [number]enum
# \begin{enumerate}
#   item*[number]
# \end{enumerate}
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)enum' "LaTeX enumerate" brA
\begin{enumerate}
`!p
res = "\t\\item $1"
if match.group(1):
	res = create_matrix(1, match.group(1), "", "\t\\item ", "\n")
	snip.rv = res
`
\end{enumerate}$0
endsnippet

# Usage:
# [number]desc
# \begin{description}
#   item*[number]
# \end{description}
context "math()"
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)desc' "LaTeX description" brA
\begin{description}
`!p
res = "\t\\item $1"
if match.group(1):
	res = create_matrix(1, match.group(1), "", "\t\\item ", "\n")
	snip.rv = res
`
\end{description}$0
endsnippet

# Brackets
# ============================================================

context "math()"
snippet bg) "LaTeX big parenthesis" iA
\bigl( ${1:${VISUAL}} \bigr)$0
endsnippet

context "math()"
snippet Bg) "LaTeX very big parenthesis" iA
\Bigl( ${1:${VISUAL}} \Bigr)$0
endsnippet

context "math()"
snippet bg] "LaTeX big brackets" iA
\bigl[ ${1:${VISUAL}} \bigr]$0
endsnippet

context "math()"
snippet Bg] "LaTeX big brackets" iA
\Bigl[ ${1:${VISUAL}} \Bigr]$0
endsnippet

context "math()"
snippet bg} "LaTeX very big braces" iA
\bigl\\{ ${1:${VISUAL}} \bigr\\}$0
endsnippet

context "math()"
snippet Bg} "LaTeX very big braces" iA
\Bigl\\{ ${1:${VISUAL}} \Bigr\\}$0
endsnippet

context "math()"
snippet bg| "LaTeX big pipe" iA
\bigl| ${1:${VISUAL}} \bigr|$0
endsnippet

context "math()"
snippet Bg| "LaTeX very big pipe" iA
\Bigl| ${1:${VISUAL}} \Bigr|$0
endsnippet

context "math()"
snippet bg\| "LaTeX big double pipe" iA
\bigl\\| ${1:${VISUAL}} \bigr\\|$0
endsnippet

context "math()"
snippet Bg\| "LaTeX very big double pipe" iA
\Bigl\\| ${1:${VISUAL}} \Bigr\\|$0
endsnippet

context "math()"
snippet lr) "LaTeX left right parenthesis" iA
\left( ${1:${VISUAL}} \right)$0
endsnippet

context "math()"
snippet lr] "LaTeX left right brackets" iA
\left[ ${1:${VISUAL}} \right]$0
endsnippet

context "math()"
snippet lr} "LaTeX left right braces" iA
\left\\{ ${1:${VISUAL}} \right\\}$0
endsnippet

context "math()"
snippet lr| "LaTeX left right pipe" iA
\left| ${1:${VISUAL}} \right|$0
endsnippet

context "math()"
snippet lr\| "LaTeX left right double pipe" iA
\left\| ${1:${VISUAL}} \right\|$0
endsnippet

context "math()"
snippet lr> "LaTeX left right double pipe" iA
\left< ${1:${VISUAL}} \right>$0
endsnippet

context "math()"
snippet lra "LaTeX angled brackets" iA
\left\langle ${1:${VISUAL}} \right\rangle$0
endsnippet

context "math()"
snippet lrc "LaTeX left right ceiling" iA
\left\lceil ${1:${VISUAL}} \right\rceil$0
endsnippet

context "math()"
snippet lrf "LaTeX left right floor" iA
\left\lfloor ${1:${VISUAL}} \right\rfloor$0
endsnippet

