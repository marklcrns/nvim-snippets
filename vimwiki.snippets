# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# Mathjax snippets reference:
# https://github.com/gillescastel/latex-snippets/blob/master/tex.snippets

global !p
import os, re
from datetime import datetime, timedelta, date

def get_wiki_files_dir():
	root = os.getcwd()
	rel_path = re.sub(root, '', path)			# strip root dir from abs filepath
	dir_path = re.sub(fn, '', rel_path) # remove current buffer file from path
	subdir_count = 0
	wiki_path = ''

	try:
		if 'md/' in dir_path:
			file_index_end =  dir_path.index('md/') + 2 # Get the end index of 'md' dir
			stripped_path = dir_path[file_index_end:]		# Strip trailing path from after 'md' dir
			wiki_path = dir_path[file_index_end + 1:]
			# Count how deep current buffer dir relative to 'md' dir or stripped path
			for i in stripped_path:
				if i == '/':
					subdir_count += 1
	except ValueError:
		return # Return nothing if no 'md' dir

	# return path to 'files/' dir relative to current buffer dir
	return "../" * subdir_count + "files/" + wiki_path


def get_nearest_glossary():
	bib='glossary.md'

	if fn in bib: return ''

	abs_path = os.path.abspath(path)
	dir_path = os.path.dirname(abs_path) # remove current file from path
	subdir_count = 0
	wiki_path = ''

	while '/md/' in dir_path:
		if os.path.exists(dir_path + '/' + bib): break
		dir_path = os.path.dirname(dir_path)
		subdir_count += 1

	return "../" * subdir_count + bib


# Make all multi-line placeholder strings jumpable.
def create_matrix_placeholders(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""

	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]

  # Append current line into anonymous snippet
	for i in range(start, end + 1):
		anon_snippet_body += snip.buffer[i]
		anon_snippet_body += "" if i == end else "\n"

	# Delete expanded snippet line till second to last line
	for i in range(start, end):
		del snip.buffer[start]

	# Empty last expanded snippet line while preserving the line
	snip.buffer[start] = ''

	# Expand anonymous snippet
	snip.expand_anon(anon_snippet_body)


def create_matrix(cols, rows, sep, start, end):
	res = ""
	placeholder = 1
	for _ in range(0, int(rows)):
		res += start + f"${placeholder}"
		placeholder += 1
		for _ in range(0, int(cols) - 1):
			res += sep + f"${placeholder}"
			placeholder += 1
		res += end
	return res[:-1]


def get_parent_header(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""
	# Get start of snippet as the end of line
	end = snip.snippet_start[0]

	# Append current line into anonymous snippet
	for i in reversed(range(0, end)):
		if (snip.buffer[i].find('#') == 0):
			return snip.buffer[i]
	
	return ""


# Gets next day of the week. Returns today's date if, say '6' was passed in, and
# today is sunday.
# Sample usage: get_next_week_date(6, 1), will return the date of next "Sunday"
# Sample usage: get_next_week_date(0, 2), will return the date of next next "Monday"
# https://stackoverflow.com/a/8801197/11850077
def get_next_week_date(week_date, next_date):
	day = date.today()
	i = 0
	while i != next_date:
		day += timedelta(1)
		if day.weekday() == week_date:
			i += 1
	return day


# Same as get_next_week_date() but for last week instead.
def get_last_week_date(week_date, last_date):
	day = date.today()
	i = 0
	while i != last_date:
		day -= timedelta(1)
		if day.weekday() == week_date:
			i += 1
	return day


def get_date_from_now(next_date):
	day = date.today() + timedelta(next_date)
	return day


# https://stackoverflow.com/a/13565185/11850077
def get_last_day_of_month(ref_date):
	end = ref_date.replace(day=28) + timedelta(days=4)  # this will never fail
	end = end - timedelta(days=end.day)
	return end


# https://stackoverflow.com/a/59199379/11850077
def get_start_of_next_month(ref_date):
    start = (ref_date.replace(day=1) + timedelta(days=32)).replace(day=1)
    return start

# Mathjax matrix dictionary
boundaries = {
	"b": ["[", "]"],
	"B": ["\\\{", "\\\}"],
	"p": ["(", ")"],
	"v": ["|", "|"],
	"V": ["||", "||"]
}

weekdays = {
	"0": "Monday",
	"1": "Tuesday",
	"2": "Wednesday",
	"3": "Thursday",
	"4": "Friday",
	"5": "Saturday",
	"6": "Sunday"
}

# Todo meds task
def create_meds_task_head(desc, time):
	time = int(time)
	str_date_time = ""

	if time > 2399:
		time = time - 2400

	if time > 999:
		str_date_time += str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 1000 and time > 99:
		str_date_time += "0" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 100 and time > 0:
		str_date_time += "00" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time == 0:
		str_date_time += "00:00"

	str_date_time = "(" + tomorrow + " " + str_date_time + ")"

	task =  desc + " " + str_date_time
	return task

def create_meds_task(desc, time, offset):
	time = int(time) + (offset)
	date = today
	str_time = ""
	str_date_time = ""

	if time > 2399:
		time = time - 2400
		date = tomorrow

	if time > 999:
		str_time += str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 1000 and time > 99:
		str_time += "0" + str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += "0" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 100 and time > 0:
		str_time += "00" + str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += "00" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time == 0:
		str_time += "00:00"
		str_date_time += "00:00"

	str_date_time = "(" + date + " " + str_date_time + ")"

	task =  str_time + " " + desc + " " + str_date_time
	return task
endglobal

# ====================Vimwiki/Markdown Snippets====================

snippet h1 "Header 1" b
# $1
$0
endsnippet

snippet h2 "Header 2" b
## $1
$0
endsnippet

snippet h3 "Header 3" b
### $1
$0
endsnippet

snippet h4 "Header 4" b
#### $1
$0
endsnippet

snippet h5 "Header 5" b
##### $1
$0
endsnippet

snippet h6 "Header 6" b
###### $1
$0
endsnippet

snippet tag "HTML tag <>" b
<$1>

${0:${VISUAL}}

</$1>
endsnippet

snippet itag "In-line HTML tag <>" w
<$1>${0:${VISUAL}}</$1>
endsnippet

snippet '(.+)?fen' "Fenced code block" rb
\`\`\``!p snip.rv = "" if match.group(1) == None else match.group(1)`
${0:${VISUAL}}
\`\`\`
endsnippet

snippet mcom "Markdown comment" b
[$1]: # $0
endsnippet

snippet hcom "Markdown comment" b
<!--- $1 --->$0
endsnippet

snippet br "Markdown breakline" w
<br>
endsnippet

snippet l "Simple link"
[${1:${VISUAL}}]($2)$0
endsnippet

snippet w "Web link"
[📄 ${1:${VISUAL}}]($2)$0
endsnippet

snippet m "Markdown file link" w
[↪ ${1:${VISUAL}}]($2)$0
endsnippet

snippet v "Video link" w
[📺 ${1:${VISUAL}}]($2)$0
endsnippet

snippet ve "YouTube Video link with embedded image" w
[📺 ${1:${VISUAL}}]($2)$0

[<img src="https://img.youtube.com/vi/${2/.*(watch\?v=|\/embed\/)([a-zA-Z0-9-_]*)((&|\/|)?.*)?/$2/}/0.jpg" alt="$1" width="200"/>](https://www.youtube.com/embed/${2/.*(watch\?v=|\/embed\/)([a-zA-Z0-9-_]*)((&|\/|)?.*)?/$2//$1/} "$1")
endsnippet

snippet p "Video playlist link" w
[💽 ${1:${VISUAL}}]($2)$0
endsnippet

snippet f "File Link" w
[⬇ ${1:${VISUAL}}](file:`!p snip.rv = get_wiki_files_dir()`$2)$0
endsnippet

snippet vf "vfile link" w
[⬇ ${1:${VISUAL}}](vfile:`!p snip.rv = get_wiki_files_dir()`$2)$0
endsnippet

snippet i "Image link" w
![${1:${VISUAL}}](`!p snip.rv = get_wiki_files_dir()`$2)$0
endsnippet

snippet ie "Clickable Image link" w
[![${1:${VISUAL}}](${2:path/to/image})](${3:redirect-link} "${4:Alt}")
endsnippet

snippet ih "HTML Image link" w
<a id="$1">
	<img data-enlargeable style="cursor: zoom-in"
	src="`!p snip.rv = get_wiki_files_dir()`$1.${2:png}"
	width="${3:500px}" alt="${4:alt}">
</a>

> $4
endsnippet

snippet a "Markdown anchor link" w
[📑 ${1:${VISUAL}}](${2:file}#${1/(^[^a-zA-Z]+)?([a-zA-Z0-9.-]+)(\s*)/\L$2(?3:-)\E/g})$0
endsnippet

snippet '#(.*)&a' "Convert anchor name ref into valid html id" ir
`!p
ref = match.group(1)

ref = re.sub(r'^\d+\.*\s*', '', ref.lower())

# Transform special chars into uniformed separators
ref = ref.replace(' ', '-')
ref = ref.replace('_', '-')
ref = ref.replace('\`', '-')
ref = ref.replace('.', '-')
ref = ref.replace(',', '')
ref = ref.replace('\'', '')

snip.rv = '#' + ref
`
endsnippet

snippet pre "Html code block tag" w
<pre>
$0
</pre>
endsnippet

snippet kbd "Markdown key bindings tag" w
<kbd>${1:${VISUAL}}</kbd>$0
endsnippet

snippet ** "Markdown Bold" i
**${1:${VISUAL}}**$0
endsnippet

snippet __ "Markdown Italic" i
_${1:${VISUAL}}_$0
endsnippet

snippet ~~ "Markdown Strikethrough" i
~~${1:${VISUAL}}~~$0
endsnippet

snippet hbo "Html bold tag" w
<b>${1:${VISUAL}}</b>$0
endsnippet

snippet hit "Html italic tag" w
<i>${1:${VISUAL}}</i>$0
endsnippet

snippet meta "Meta deta template" b
---
title: ${1:(INSERT TITLE)}
subtitle: ${2:(INSERT SUBTITLE)}
author: ${3:Mark Lucernas}
date: `date +'%b %d, %Y'`
---


$0
endsnippet

snippet temp "Vimwiki document template" b
---
title: ${1:(INSERT TITLE)}
subtitle: ${2:(INSERT SUBTITLE)}
author: ${3:Mark Lucernas}
date: `date +'%b %d, %Y'`
---


# $1: $2

$0


<br>

# Resources

endsnippet

snippet res "Vimwiki document resources header" b
<br>

# Resources

endsnippet

# Creates Todo list with Task Warrior.
# Prepend "!" to include weekly and monthly todos
# Prepend "@" to include overdue todos
# Prepend "&" to generate nested side todo templates
# Prepend "&&" to generate nested todo ONLY
post_jump "create_matrix_placeholders(snip)"
snippet '([!@&0-9]+)?td' "To-do list template" rb
`!p
# parse date filename
fn_date = fn.rstrip('.md')
fn_date = fn_date.split("-")
flags = match.group(1) if match.group(1) != None else ""

# Format date string
date_format = '%Y-%m-%d'
date_format_verbose = '%b %d, %Y'
default_due_time = 'T23:59:00'

base = datetime(int(fn_date[0]), int(fn_date[1]), int(fn_date[2]))
base_tomorrow = datetime(int(fn_date[0]), int(fn_date[1]), int(fn_date[2])) + timedelta(1)
base_yesterday = datetime(int(fn_date[0]), int(fn_date[1]), int(fn_date[2])) - timedelta(1)

today = datetime.strftime(base, date_format)
tomorrow = datetime.strftime(base_tomorrow, date_format)
yesterday = datetime.strftime(base_yesterday, date_format)

today_verbose = datetime.strftime(base, date_format_verbose)

end_of_today = today + default_due_time
end_of_tomorrow = tomorrow + default_due_time
end_of_yesterday = yesterday + default_due_time
end_of_week = (get_next_week_date(6, 1)).strftime(date_format) + default_due_time
end_of_next_week = (get_next_week_date(6, 2)).strftime(date_format) + default_due_time
end_of_last_week = (get_last_week_date(6, 2)).strftime(date_format) + default_due_time
end_of_month = get_last_day_of_month(base).strftime(date_format) + default_due_time

# Meta
title = f"title: TODO list"
subtitle = f"subtitle: {weekdays[str(base.weekday())]} to-do list. Managed by Taskwarrior and Taskwiki"
author = "author: Mark Lucernas"
date = f"date: {today_verbose}"
meta = f"---\n{title}\n{subtitle}\n{author}\n{date}\n---\n\n\n"

# Task warrior filters
proj = "proj:Todo"
# sched = f"sched:{today}"
due_today = f"due:{end_of_today}"
due_tomorrow = f"due:{end_of_tomorrow}"
due_yesterday = f"due:{end_of_yesterday}"
due_weekly = f"due:{end_of_week}"
due_monthly = f"due:{end_of_month}"
due_this_week = f"due.after:{end_of_yesterday} due.before:{end_of_week}"
due_next_week = f"due.after:{end_of_week} due.before:{end_of_next_week}"
due_last_week = f"due.after:{end_of_last_week} due.before:{end_of_yesterday}"
due_this_month = f"due.after:{end_of_yesterday} due.before:{end_of_month}"

result = ""
task_checkbox = "* [ ] "
separator = "--------------------------------------------------------------------------------\n\n"

# Main header
if "&&" not in flags:
	main_header = meta + "# Todo List || -VISIBLE " + proj + "\n"
	result += main_header + "\n"

# Overdue
if "@" in flags:
	overdue_task_header = "## 🔥 Overdue"
	overdue_task_filter = " | +OVERDUE"
	result += overdue_task_header
	result += overdue_task_filter + "\n\n"

# Append side task snippet into result if '&' flag was given
if "&" in flags:
	# Extract multiplier from flag if any
	mult = [int(c) for c in flags if c.isdigit()]
	mult = mult[0] if mult else 1

	for i in range(1, (mult * 3) + 1, 3):
		side_task_header = "## ${" + str(i) + ":Side}"
		side_task_filter = " | +${" + str(i) + "/(\w+)\s*/\L$1\E/g} +PENDING -OVERDUE priority:${" + str(i + 1) + ":H}" + " " + due_today
		result += side_task_header
		result += side_task_filter + "\n"
		result += task_checkbox + "$" + str(i + 2)
		# Single new line on last iteration if conditions are met
		if i <= (mult * 3) - 3:
			result += "\n\n"
		elif "&&" not in flags or "!" in flags or '@' in flags:
			result += "\n"

	result += "\n"

if "&&" not in flags:

	result += separator

	reminders_task_header = "## 🔔 Reminders"
	reminders_task_filter = " | +remind -COMPLETED priority:L"
	result += reminders_task_header
	result += reminders_task_filter + "\n\n"

	result += separator

	# Today
	today_task_header = "## 🏃 Today"
	today_task_filter = " | +PENDING -OVERDUE " + due_today
	result += today_task_header
	result += today_task_filter + "\n"
	result += task_checkbox + '$0' + "\n\n"

	# Next 14 days
	for i in range(1, 15):
		next_date = base + timedelta(i)
		next_day_task_header = "## 🌛 " + weekdays[str(next_date.weekday())]
		next_day_task_filter = " | +PENDING -OVERDUE due:" + datetime.strftime(next_date, date_format) + default_due_time + "\n"
		result += next_day_task_header
		result += next_day_task_filter + "\n"

	# Someday task header
	someday_task_header = "## 🔜 Someday"
	someday_task_filter = " | +someday wait:later -COMPLETED"
	result += someday_task_header
	result += someday_task_filter + "\n\n"

	result += separator

	# Weekly
	end_of_week_header = "## 🚶 Weekly"
	end_of_week_filter = " | -OVERDUE +weekly " + due_weekly
	result += end_of_week_header
	result += end_of_week_filter + "\n\n"

	# This month
	end_of_month_header = "## 📆 Monthly"
	end_of_month_filter = " | -OVERDUE +monthly " + due_monthly
	result += end_of_month_header
	result += end_of_month_filter + "\n\n"

	result += separator

	# weekly and monthly tasks
	if "!" in flags:
		# This week
		end_of_week_header = "## This Week"
		end_of_week_filter = " | -OVERDUE " + due_this_week
		result += end_of_week_header
		result += end_of_week_filter + "\n\n"

		# Next week
		end_of_next_week_header = "## Next Week"
		end_of_next_week_filter = " | -OVERDUE " + due_next_week
		result += end_of_next_week_header
		result += end_of_next_week_filter + "\n\n"

		# This month
		end_of_month_header = "## This Month"
		end_of_month_filter = " | -OVERDUE " + due_this_month
		result += end_of_month_header
		result += end_of_month_filter + "\n\n"

		result += separator

	# # Yesterday task header
	# yesterday_task_header = "## 🌜 Yesterday"
	# yesterday_task_filter = " | -OVERDUE " + due_yesterday
	# result += yesterday_task_header
	# result += yesterday_task_filter + "\n\n"

	# Last week task header
	last_week_task_header = "## 🌜 Last Week"
	last_week_task_filter = " | -OVERDUE " + due_last_week
	result += last_week_task_header
	result += last_week_task_filter + "\n\n"

# Output
snip.rv = result`
endsnippet

# Usage
# 16:30:30-16:40:30-10tt
# 16:30:30-16:40:30tt
# 16:59tt
post_jump "create_matrix_placeholders(snip)"
snippet '(([0-2]?[0-9]):([0-6][0-9])(:([0-5][0-9]))?)(-([0-2]?[0-9]):([0-5][0-9])(:([0-5][0-9]))?)?(-([0-9]+))?(h)?tt' "To-do list time template generator" rb
`!p
from_hrs = match.group(2) if match.group(2) != None else "00"
from_mins = match.group(3) if match.group(3) != None else "00"
from_secs = match.group(5) if match.group(5) != None else "00"
to_hrs = match.group(7) if match.group(7) != None else "00"
to_mins = match.group(8) if match.group(8) != None else "00"
to_secs = match.group(10) if match.group(10) != None else "00"
steps = int(match.group(12)) * 60 if match.group(12) != None else 1800
inherit_header = True if match.group(13) != None else False

time_format = "%H:%M:%S"
from_time = datetime.strptime(f"{from_hrs}:{from_mins}:{from_secs}", time_format)
to_time = datetime.strptime(f"{to_hrs}:{to_mins}:{to_secs}", time_format)
from_total_time_secs = sum(x * int(t) for x, t in zip([3600, 60, 1], f"{from_hrs}:{from_mins}:{from_secs}".split(":"))) 
to_total_time_secs = sum(x * int(t) for x, t in zip([3600, 60, 1], f"{to_hrs}:{to_mins}:{to_secs}".split(":"))) 

header_hash = "#"
header_name = ""
date = ""
result = ""

# Get parent header infos
parent_header = get_parent_header(snip)
filter_idx = parent_header.find('|') if parent_header.find('||') == -1 else -1
filters = parent_header[filter_idx:] if filter_idx != -1 else "|"
filters = filters.replace(' -SCHEDULED', '')

if parent_header != None:
	header_hash += parent_header[parent_header.find('#'):parent_header.find(' ')]
	if inherit_header:
		header_name = parent_header[parent_header.find(' '):parent_header.find('|') - 1]

# Get header due date, else filename
if parent_header.find('due:') != -1:
	idx = parent_header.find('due:')
	date = parent_header[idx + 4:parent_header.find('T', idx)]
else:
	fn_date = fn.rstrip('.md')
	date = fn_date.replace('-', ':')

if to_total_time_secs == 0:
	time_on = str(timedelta(seconds=from_total_time_secs))
	time_before = str(timedelta(seconds=from_total_time_secs + 60))
	time_after = str(timedelta(seconds=from_total_time_secs - 60))
	result += f"{header_hash}{header_name} {time_on} {filters} sched:{date}T{time_on} sched.before:{date}T{time_before} sched.after:{date}T{time_after}\n"
	result += "* [ ] $0"
else:
	while (from_total_time_secs <= to_total_time_secs):
		time_on = str(timedelta(seconds=from_total_time_secs))
		time_before = str(timedelta(seconds=from_total_time_secs + 60))
		time_after = str(timedelta(seconds=from_total_time_secs - 60))
		result += f"{header_hash}{header_name} {time_on} {filters} sched:{date}T{time_on} sched.before:{date}T{time_before} sched.after:{date}T{time_after}\n"
		from_total_time_secs += steps

# Output
snip.rv =  result`
endsnippet

snippet '(\d+)meds' "Description" rb
`!p
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
init_time = match.group(1)
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
today = datetime.strftime(base, '%Y-%m-%d')
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
`* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 600)`
* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 800)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 1600)`
* [ ] `!p snip.rv = create_meds_task("1 Aspirin EC 12hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("1 Aspirin EC 12hrs", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("2 Sennosides-docusate 2daily", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("2 Sennosides-docusate 2daily", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("1 Famotidine 1daily", init_time, 400)`
endsnippet

snippet due "Description" w
`!p
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
snip.rv = "(" + tomorrow + ")"`
endsnippet

snippet task "Todo/Task checkbox" bA
* [ ] $0
endsnippet

post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)([cC]{1,2})?t' "Markdown table (n)t" br
`!p
t_column_ct = int(match.group(1))
flags = match.group(2) if match.group(2) != None else ""

t_head = "| $0  "
t_sep = "|:-:" if 'C' in flags else "|---"
t_cell = "|   "

t_header = t_head + (t_cell * (t_column_ct - 1)) + "|"
t_sep = t_sep + (t_sep * (t_column_ct - 1)) + "|"
t_body = t_cell + (t_cell * (t_column_ct - 1)) + "|"

result = t_header + "\n" + t_sep + "\n" + t_body

if 'c' in flags:
	result = "<center>\n\n" + result + "\n\n</center>\n"

snip.rv = result
`
endsnippet

# Usage: [wrap]?table, optional wrapper char for each table cell
# Note: Lines should trail '&' char for splitting. Only until second to last.
# Ref: http://vimcasts.org/episodes/ultisnips-visual-placeholder/
snippet '([`$_*])?([cC]{1,2})?atab' "Markdown Table Builder" rb
`!p
# Fetch visual selected text
wrap_char =  match.group(1) if match.group(1) != None else "" # Wraper char to wrap table cell items
flags = match.group(2) if match.group(2) != None else ""
text = snip.v.text

if match.group(1) != None:
	if wrap_char == '$': # '\\' to escape '$' wrap char
		wrap = "\\" + wrap_char
	elif wrap_char == '*':
		wrap = "**"
	else:
		wrap = wrap_char
else:
	wrap = ""

delim = "\t" # Delimeter
lines = text.split("\n") # Split lines delimited by new line
result = "" # String container to be returned
line_count = 0
for line in lines[:-1]: # Loop over lines
	line_tmp = ""
	separator = ""
	line = line.split(delim) # Split all items in line
	for item in line: # Loop over items in lines
		# Strip leading and trailing whitespaces
		item = item.lstrip().rstrip()

		if line_count == 0:
			line_tmp += "| " + item + " " # Format without wrap and append item to line
			if 'C' in flags:
				separator += "|:" + ("-" * (len(item))) + ":" # Centered table contents
			else:
				separator += "|" + ("-" * (len(item) + 2))

		if line_count >= 1:
			line_tmp += "| " + wrap + item + wrap + " " # Format with wrap and append item to line

	result += line_tmp + "|\n" # Append new line and close table row

	if line_count == 0: # Table header and body separator
		result += separator + "|\n"

	line_count += 1

if 'c' in flags:
	result = "<center>\n\n" + result + "\n</center>\n"

snip.rv = result
`
endsnippet

snippet tab2 "Two tables side by side" b
<center>

<table>
%% Table Headings are OPTIONAL
<tr><th>${1:Table Heading 1}</th><th>${2:Table Heading 2}</th></tr>
<tr><td>

%% Insert first table HERE

</td><td>

%% Insert second table HERE

</td></tr>
</table>

</center>
endsnippet

snippet tab3 "Three tables side by side" b
<center>

<table>
%% Table Headings are OPTIONAL
<tr><th>${1:Table Heading 1}</th><th>${2:Table Heading 2}</th><th>${3:Table Heading 3}</th></tr>
<tr><td>

%% Insert first table HERE

</td><td>

%% Insert second table HERE

</td><td>

%% Insert Third table HERE

</td></tr>
</table>

</center>
endsnippet

snippet TM "Markdown trademark symbol" i
&trade;
endsnippet

snippet R "Markdown registered symbol" i
&reg;
endsnippet

snippet C "Markdown copyright symbol" i
&copy;
endsnippet

# ==========Note taking snippets========== #
snippet tstamp "Video lecture timestamps" b
Timestamps

	$0
endsnippet

snippet ttime "Video lecture timestamp item" i
- ${1:title} ${2:1:00}
endsnippet

# Usage: <youtube-url>&e
post_jump "create_matrix_placeholders(snip)"
snippet '((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))&e' "YouTube pseudo embedded video" wr
`!p
home_url = match.group(1)
http_url = match.group(2)
www_url = match.group(3)
domain_url = match.group(4)
video_url = match.group(5)
video_mode = match.group(6)
video_id = match.group(7)
link = "https://www.youtube.com"

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# snip.rv = "[![${1:Alt text}](https://img.youtube.com/vi/" + video_id + "/2.jpg)](" + link + "${1/.*/ \"$0\"/})$0"
snip.rv = "[<img src=\"https://img.youtube.com/vi/" + video_id + "/0.jpg\" alt=\"${1:Alt text}\" width=\"200\"/>](" + link + "${1/.*/ \"$0\"/})$0"
`
endsnippet

# Usage: (00:00:00 or 00:00)<youtube-url>&t
snippet '((\d{1,2}:)?(\d{1,2}):(\d{2}))((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))&t' "YouTube url with time stamp" wrA
[(`!p snip.rv = match.group(1)`)](`!p
# check if hours exist
hours = match.group(2)
if hours:
	hours = int(hours).rstrip(":")
else:
	hours = 0

minutes = int(match.group(3))
seconds = int(match.group(4))
home_url = match.group(5)
http_url = match.group(6)
www_url = match.group(7)
domain_url = match.group(8)
video_url = match.group(9)
video_mode = match.group(10)
video_id = match.group(11)
link = "https://www.youtube.com"

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# convert timestamp to seconds then append to link
snip.rv = link + "&t=" + str((hours * 60) + (minutes * 60) + seconds)
`)
endsnippet

# Usage: <youtube-url>&y
post_jump "create_matrix_placeholders(snip)"
snippet '(\()?((https:\/\/)?(www\.)?(youtube.com))((\/embed\/|\/watch\?v=)?(.*))&y' "Clean and create Youtube link" wr
`!p
home_url = match.group(2)
http_url = match.group(3)
www_url = match.group(4)
domain_url = match.group(5)
video_url = match.group(6)
video_mode = match.group(7)
video_id = match.group(8)
link = "https://www.youtube.com"

# check if video_url is embedded
if 'embed' in video_mode:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# If inside markdown link wrapper, don't wrap, else, wrap it.
if match.group(1):
  snip.rv = match.group(1) + link
else:
	snip.rv = "[📺 $1](" + link + ")$0"
`
endsnippet

# Usage: &name-of-link&alink
snippet '&?([A-Za-z- ]+)\&(t)?alink' "Word or pharse definition auto" wr
[`!p
snip.rv = match.group(1).replace("-", " ")
`]($1#${2:`!p
		snip.rv = match.group(1).replace(" ", "-").lower() if match.group(2) == None else match.group(1).replace(" ", "-").lower() + "-term"
`})$0
endsnippet

# USAGE
# Termininology name&iterm
# **Terminology name**&term
# **terminology name**&iterm
#
# In-line flag:
# &terminology name&term -- in-line definition
# terminology name&iterm -- same line definition
#
# Abbreviation flag:
# terminology name&aterm
# &terminology name&aterm
#
# Capitalization flags:
# terminology name&cterm -- capitalize
# &terminology name&tterm -- titlelize
#
# Mixed flags:
# terminology name&iaterm -- same line definition with abbrev
# terminology name&iacterm -- capitalized same line definition with abbrev
# a, i, c or t flags are interchangeable
post_jump "create_matrix_placeholders(snip)"
snippet '(&)?(\*\*)?([^.*\[\]#&]+)(\*\*)?&([ia(t|c)]{1,3})?term$' "Word or phrase definition auto" wr
`!p
orig_term = match.group(3).lstrip().rstrip()
flags = match.group(5)
text = ""
copy = True
# Check if theres parenthesis and exclude its contents from anchor link
parenthesis = set('()')
if any((c in parenthesis) for c in orig_term):
	for i in range(0, len(orig_term) - 1):
		if ((orig_term[i] == "(" or orig_term[i + 1] == "(") and copy == True):
			copy = False
			continue
		elif (orig_term[i] == ")" and copy == False):
			copy = True
			continue

		if copy == True:
			text += orig_term[i]
else:
  text = orig_term

# Anchor link with '-term' appended to name
anchor = "<a id=\"" + text.replace("'", "").replace(" ", "-").lower() + "-term\">"
# Flags
if flags:
	# Abbreviation
	if 'a' in flags:
		# Credits: https://stackoverflow.com/a/41191867/11850077
		abbrev = (" (" + ''.join([s[0] for s in orig_term.split()]).upper() + ")")
	else:
		abbrev = ""
	# In-line
	if match.group(1):	# In-line definition. If term sandwhiched by '&'
		end = "$0"
	elif 'i' in flags:				# Same line definition
		end = ": $0<br>"
	else:
		end = "\n\n:   $0"				# Multi-line definition
	# Capitalizations
	if 'c' in flags:					# Capitalize term
		term = orig_term.capitalize()
	elif 't' in flags:				# Titlelize term
		term = orig_term.title()
	else:
		term = orig_term
else:
	abbrev = ""
	if match.group(1):	# In-line definition. If term sandwhiched by '&'
		end = "$0"
	else:
		end = "\n\n:   $0"
	term = orig_term

snip.rv = anchor + "**" + term + abbrev + "**</a>" + end`
endsnippet

snippet aterm "Markdown term anchor link" w
[${1:${VISUAL}}](${2:`!p snip.rv = get_nearest_glossary()`}#${1/(^[^a-zA-Z]+)?([a-zA-Z0-9.-]+)(\s*)/\L$2(?3:-)\E/g}-term)$0
endsnippet

# ====================LaTeX/Mathjax Snippets==================== #

snippet '(?<!\\|\)|\])\$([0-9]+,[0-9]+(\.[0-9]+)?)\s(?!\$)' "LaTeX auto currency" rwA
`!p snip.rv = "\$" + match.group(1) + " "`
endsnippet

# Symbols (Relations)
# ============================================================

snippet <= "LaTeX less than or equals to" iA
\leq
endsnippet

snippet >= "LaTeX greater than or equals to" iA
\geq
endsnippet

snippet >> "LaTeX much greater than" iA
\gg
endsnippet

snippet << "LaTeX muchn less than" iA
\ll
endsnippet

snippet != "LaTeX not equals to" iA
\neq
endsnippet

snippet ~~ "LaTeX approximation symbol" iA
\approx
endsnippet

snippet ~= "LaTeX congruent symbol" iA
\cong
endsnippet

snippet -= "LaTeX equivalent symbol" iA
\equiv
endsnippet

snippet => "LaTeX implies symbol" iA
\implies
endsnippet

snippet =< "LaTeX implied by symbol" iA
\impliedby
endsnippet

snippet def= "Latex define equal symbol" iA
\overset{\underset{\mathrm{def}}{}}{=}
endsnippet

snippet sim "Latex symmetrical symbol" iA
\sim
endsnippet

snippet prop "LaTeX proportional to symbol" i
\propto
endsnippet

snippet 'iff' "LaTeX if and only if symbol" i
\iff
endsnippet

snippet psub "Latex proper subset symbol" i
\subset
endsnippet

snippet npsub "Latex not a proper subset symbol" i
\not\subset
endsnippet

snippet sub "Latex subset symbol" i
\subseteq
endsnippet

snippet nsub "Latex not a subset symbol" i
\not\subseteq
endsnippet

snippet sup "Latex superset symbol" i
\superset
endsnippet

snippet nsup "Latex not a superset symbol" i
\not\superset
endsnippet

snippet !0 "Latex emptyset symbol" i
\emptyset
endsnippet

snippet in "Latex in symbol" w
\in
endsnippet

snippet nin "Latex not in symbol" i
\not\in
endsnippet

snippet ni "Latex in reverse symbol" w
\ni
endsnippet

snippet nin "Latex not in reverse symbol" i
\not\ni
endsnippet

# Exponents, Superscript, Subscript
# ============================================================

# Auto exponent/superscript
# Matches ^ followed by pattern of characters using negative lookbehind
snippet '((?<=[a-zA-Z0-9]|\)|\}|\])|(?<=sin|cos|tan|csc|sec|cot))\^' "LaTeX auto exponent/superscript" irA
^{$1}$0
endsnippet

snippet '((?<=[a-zA-Z0-9]|\)|\}|\])|(?<=sin|cos|tan|csc|sec|cot))_' "LaTeX auto subscript" irA
_{$1}$0
endsnippet

# Math
# ============================================================

# Usage:
# f// -> \frac{$1}{$2}$0
# df// -> \dfrac{$1}{$2}$0
# tf// -> \tfrac{$1}{$2}$0
snippet '(d|t)?f//' "LaTeX normal/display/textstyle fraction" riA
`!p
snip.rv = "\\" if match.group(1) == None else "\\" + match.group(1)
`frac{${1:${VISUAL}}}{$2}$0
endsnippet

# Usage:
# b// -> \binom{$1}{$2}$0
snippet b// "LaTeX symbol binomial coefficient" iA
\binom{${1:${VISUAL}}}{$2}$0
endsnippet

# Usage:
# abc/f/ -> \frac{abc}{$0}
# (abc)/f/ -> \frac{abc}{$0}
snippet '(\()?(.*)(\))?/f/' "LaTeX () auto fraction" wrA
\frac{`!p snip.rv = match.group(2)`}{$0}
endsnippet

# Usage:
# abc/b/ -> \binom{abc}{$0}
# (abc)/b/ -> \binom{abc}{$0}
snippet '(\()?(.*)(\))?/b/' "LaTeX () auto binomial" wrA
\binom{`!p snip.rv = match.group(2)`}{$0}
endsnippet

snippet sqrt "LaTeX square root" iA
\sqrt{${1:${VISUAL}}}$0
endsnippet

snippet '(\d+|n|x|y|z)root' "LaTeX root of n" irA
\sqrt[`!p snip.rv = match.group(1)`]{$1}$0
endsnippet

# Logarthmic function
snippet '(log|ln)([a-zA-Z0-9]{1,5})?' "LaTeX Logarithmic function" rw
`!p
log = match.group(1)
base = "_{" + match.group(2) + "}" if match.group(2) else ""
snip.rv = "\\" + log + base`($1)$0
endsnippet

snippet oo "LaTeX infinity" i
\infty
endsnippet

snippet NN "Latex large intersection" i
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

snippet UU "Latex large union" i
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet 'setm' "Latex set minus" i
\setminus
endsnippet

snippet comp "LaTeX complement" i
^{c}
endsnippet

snippet inv "LaTeX inverse" i
^{-1}
endsnippet

snippet ang "LaTeX angle symbol" i
\angle{$1}$0
endsnippet

snippet int "Latex integration" w
\int${1:_{${2:-\infty}}^{${3:\infty}}} ${4:${5:f(x)}\;dx}$0
endsnippet

snippet dint "LaTeX displaystyle integral" w
{\displaystyle \int${1:_{${2:-\infty}}^{${3:\infty}}} ${4:${5:f(x)}\;dx}}$0
endsnippet

snippet sum "LaTeX summation" w
\sum${1:_{${2:i} = ${3:1}}^{${4:n}}} ${5:${6:f(${7:x_{i}})}\;${8:\Delta{x}}}$0
endsnippet

snippet lim "Latex limit" i
\lim${1:_{${2:n} \to ${3:\infty}}} ${4:${5:f(x)} = ${6:x}}$0
endsnippet

snippet reim "LaTeX Reiman sum" w
\lim_{${1:n} \to ${2:\infty}} \sum_{${3:i} = ${3:1}}^{${4:n}} ${5:${6:f(${7:x_{i}})}${8:\Delta{x}}}$0
endsnippet

snippet lims "Latex limit superior" w
\limsup_{${1:n} \to ${2:\infty}}
endsnippet

snippet prod "Latex product" w
\prod${1:_{${2:n=${3:1}}}^{${4:\infty}}} ${5:${VISUAL}}$0
endsnippet

snippet pder "Latex partial derivative" w
\frac{\partial ${1:V}}{\partial ${2:x}}$0
endsnippet

snippet der "Latex derivative" w
\frac{d${1:V}}{d${2:x}}$0
endsnippet

snippet _} "LaTeX underbrace" iA
\underbrace{${1:${VISUAL}}}$0
endsnippet

snippet ^} "LaTeX overbrace" iA
\overbrace{${1:${VISUAL}}}$0
endsnippet

snippet PP "LaTeX prime numbers" i
\mathbb{P}
endsnippet

snippet NN "LaTeX natural numbers" i
\mathbb{N}
endsnippet

snippet ZZ "LaTeX integer numbers" i
\mathbb{Z}
endsnippet

snippet WW "LaTeX whole numbers" i
\mathbb{W}
endsnippet

snippet II "LaTeX irrational numbers" i
\mathbb{I}
endsnippet

snippet QQ "LaTeX rational numbers" i
\mathbb{Q}
endsnippet

snippet RR "LaTeX real numbers" i
\mathbb{R}
endsnippet

snippet CC "LaTeX complex numbers" i
\mathbb{C}
endsnippet

snippet SS "LaTeX section" i
\S
endsnippet

snippet iE "LaTeX exists" i
\exists
endsnippet

snippet iA "LaTeX forall" i
\forall
endsnippet

snippet xx "LaTeX cross" i
\times
endsnippet

snippet tf "LaTeX therefore symbol" i
\therefore
endsnippet

snippet bc "LaTeX because symbol" i
\because
endsnippet

snippet to "to" i
\to
endsnippet

snippet mto "mapsto" i
\mapsto
endsnippet

snippet .c "LaTeX cdot" iA
\cdot
endsnippet

snippet ..c "LaTeX center dots" iA
\cdots
endsnippet

snippet ..l "LaTeX lower dots" iA
\ldots
endsnippet

snippet ..v "LaTeX vertical dots" iA
\vdots
endsnippet

snippet ..d "LaTeX diagonal dots" iA
\ddots
endsnippet

snippet ' "LaTeX prime" i
^{\prime}
endsnippet

snippet '' "LaTeX double prime" i
^{\prime \prime}
endsnippet

snippet ~ "LaTeX ~ symbol" i
\sim
endsnippet

snippet vec "LaTeX vector" i
\vec{${1:${VISUAL}}}$0
endsnippet

snippet 'det' "LaTeX determinant" i
\det $0
endsnippet

snippet mag "LaTeX vector's magnitude" i
\\|${1:${VISUAL}}\\|$0
endsnippet

snippet hat "LaTeX hat" i
\hat{${1:${VISUAL}}}$0
endsnippet

snippet || "LaTeX parallel sign" i
\parallel
endsnippet

snippet | "LaTeX mid sign" i
\mid
endsnippet

snippet n| "LaTeX not mid sign" i
\nmid
endsnippet

snippet '(\d+)?(a)?((sin|cos|tan|csc|sec|cot)h?)(\d+[a-zA-Z0-9]*|[a-zA-Z]+|-)?' "LaTeX trig functions" r
`!p
# Constants
mult = "" if match.group(1) == None else match.group(1)
# Arc functions
if match.group(2) == 'a':
	arc = "arc"
else:
	arc = ""
# Apply sech and csch workaround to trig function
if (match.group(3) == "sech" or match.group(3) == "csch"):
	trig = "operatorname{" + match.group(3) + "}"
else:
	trig = match.group(3)
# Negative functions
if match.group(5) == None:
	expo = ""
elif match.group(5) == "-":
	expo = "^{-1}"
else:
	expo = "^{" + match.group(5) + "}"

snip.rv = mult + "\\" + arc + trig + expo
`($1)$0
endsnippet

# Symbols (Arrows)
# ============================================================

snippet Ua "LaTeX double lined uparrow" i
\Uparrow
endsnippet

snippet Da "LaTeX double lined downarrow" i
\Downarrow
endsnippet

snippet Uda "LaTeX double lined updownarrow" i
\Updownarrow
endsnippet

snippet La "LaTeX double lined leftarrow" i
\Leftarrow
endsnippet

snippet Ra "LaTeX double lined rightarrow" i
\Rightarrow
endsnippet

snippet Lra "LaTeX double lined leftrightarrow" i
\Leftrightarrow
endsnippet

snippet Lal "LaTeX double lined long leftarrow" i
\Longleftarrow
endsnippet

snippet Ral "LaTeX double lined long rightarrow" i
\Longrightarrow
endsnippet

snippet Lral "LaTeX double lined long leftrightarrow" i
\Longleftrightarrow
endsnippet

snippet da "LaTeX single lined downarrow" i
\downarrow
endsnippet

snippet uda "LaTeX single lined updownarrow" i
\updownarrow
endsnippet

snippet la "LaTeX single lined leftarrow" i
\leftarrow
endsnippet

snippet ra "LaTeX single lined rightarrow" i
\rightarrow
endsnippet

snippet lra "LaTeX single lined leftrightarrow" i
\leftrightarrow
endsnippet

snippet lal "LaTeX long single lined leftarrow" i
\longleftarrow
endsnippet

snippet ral "LaTeX long single lined rightarrow" i
\longrightarrow
endsnippet

snippet lral "LaTeX long single lined leftrightarrow" i
\Longleftrightarrow
endsnippet

snippet ^la "LaTeX overset left arrow" iA
\overset{$1}\leftarrow$0
endsnippet

snippet _la "LaTeX underset left arrow" iA
\underset{$1}\leftarrow$0
endsnippet

snippet ^ra "LaTeX overset right arrow" iA
\overset{$1}\rightarrow$0
endsnippet

snippet _ra "LaTeX underset right arrow" iA
\underset{$1}\rightarrow$0
endsnippet

# Symbols (Logic)
# ============================================================

snippet '(?<=[a-zA-Z0-9])cir' "LaTeX auto degrees symbol" irA
^{\circ}
endsnippet

snippet cir "LaTeX degrees symbol" i
\circ
endsnippet

snippet nn "Latex intersection symbol" i
\cap
endsnippet

snippet uu "Latex union symbol" i
\cup
endsnippet

# Symbols (Misc)
# ============================================================

snippet '(\+-|-\+)' "LaTeX plus minus sign" irA
\pm
endsnippet

snippet nab "Latex inverted delta greek symbol" i
\nabla
endsnippet

snippet suitc "LaTeX club suit symbol" i
\clubsuit
endsnippet

snippet suith "LaTeX heart suit symbol" i
\heartsuit
endsnippet

snippet suits "LaTeX spade suit symbol" i
\spadesuit
endsnippet

snippet suitd "LaTeX diamond suit symbol" i
\diamondsuit
endsnippet

# Symbols (Greek)
# ============================================================

snippet alp "LaTeX alpha symbol" i
\alpha
endsnippet

snippet bet "LaTeX beta symbol" i
\beta
endsnippet

snippet del "LaTeX delta symbol" i
\delta
endsnippet

snippet eps "LaTeX epsilon symbol" i
\epsilon
endsnippet

snippet veps "LaTeX varepsilon symbol" i
\varepsilon
endsnippet

snippet zet "LaTeX zeta symbol" i
\zeta
endsnippet

snippet eta "LaTeX eta symbol" i
\eta
endsnippet

snippet the "LaTeX theta symbol" i
\theta
endsnippet

snippet vthe "LaTeX vartheta symbol" i
\vartheta
endsnippet

snippet gam "LaTeX gamma symbol" i
\gamma
endsnippet

snippet kap "LaTeX gamma symbol" i
\kappa
endsnippet

snippet lam "LaTeX lambda symbol" i
\lambda
endsnippet

snippet mu "LaTeX mu greek symbol" i
\mu
endsnippet

snippet nu "LaTeX nu greek symbol" i
\nu
endsnippet

snippet xi "LaTeX xi greek symbol" i
\xi
endsnippet

snippet pi "LaTeX pi greek symbol" i
\pi
endsnippet

snippet vpi "LaTeX varpi greek symbol" i
\varpi
endsnippet

snippet rho "LaTeX rho greek symbol" i
\rho
endsnippet

snippet vrho "LaTeX phi greek symbol" i
\varrho
endsnippet

snippet sig "LaTeX sigma greek symbol" i
\sigma
endsnippet

snippet vsig "LaTeX varsigma greek symbol" i
\varsigma
endsnippet

snippet tau "LaTeX tau greek symbol" i
\tau
endsnippet

snippet ups "LaTeX upsilon greek symbol" i
\upsilon
endsnippet

snippet phi "LaTeX phi greek symbol" i
\phi
endsnippet

snippet vphi "LaTeX varphi greek symbol" i
\varphi
endsnippet

snippet chi "LaTeX chi greek symbol" i
\chi
endsnippet

snippet psi "LaTeX psi greek symbol" i
\psi
endsnippet

snippet ome "LaTeX omega greek symbol" i
\omega
endsnippet

snippet Gam "LaTeX Gamma greek symbol" i
\Gamma
endsnippet

snippet Del "LaTeX Delta greek symbol" i
\Delta
endsnippet

snippet The "LaTeX Theta greek symbol" i
\Theta
endsnippet

snippet Lam "LaTeX Lambda greek symbol" i
\Lambda
endsnippet

snippet Xi "LaTeX Xi greek symbol" i
\Xi
endsnippet

snippet Xi "LaTeX Xi greek symbol" i
\Xi
endsnippet

snippet Pi "LaTeX Pi greek symbol" i
\Pi
endsnippet

snippet Sig "LaTeX Sigma greek symbol" i
\Sigma
endsnippet

snippet Ups "LaTeX Upsilon greek symbol" i
\Upsilon
endsnippet

snippet Phi "LaTeX Phi greek symbol" i
\Phi
endsnippet

snippet Psi "LaTeX Psi greek symbol" i
\Psi
endsnippet

snippet Ome "LaTeX Omega greek symbol" i
\Omega
endsnippet

# Syntax
# ============================================================

snippet '(\\|!)!' "LaTex small negative spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\!\\!'
elif prefix == '!':
	snip.rv = '\\!'
`
endsnippet

snippet '(\\|,),' "LaTex small spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\,\\,'
elif prefix == ',':
	snip.rv = '\\,'
`
endsnippet

snippet '(\\|:):' "LaTex medium spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\:\\:'
elif prefix == ':':
	snip.rv = '\\:'
`
endsnippet

snippet '(\\|;);' "LaTex large spacing" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\;\\;'
elif prefix == ';':
	snip.rv = '\\;'
`
endsnippet

snippet dis "LaTeX Displaystyle" w
{\displaystyle ${1:${VISUAL}}}$0
endsnippet

snippet xtt "LaTeX text" iA
\text{${1:${VISUAL}}}$0
endsnippet

snippet xtbo "LaTeX text bold" iA
\textbf{${1:${VISUAL}}}$0
endsnippet

snippet xtit "LaTeX text italic" iA
\textit{${1:${VISUAL}}}$0
endsnippet

snippet xsbo "LaTeX symbol bold" iA
\boldsymbol{${1:${VISUAL}}}$0
endsnippet

snippet xmbo "LaTeX math bold" iA
\mathbf{${1:${VISUAL}}}$0
endsnippet

snippet xmit "LaTeX math italic" iA
\mathit{${1:${VISUAL}}}$0
endsnippet

snippet xmca "LaTeX mathcal" iA
\mathcal{$1}$0
endsnippet

snippet xmbb "LaTeX mathbb" iA
\mathbb{$1}$0
endsnippet

snippet pha "LaTeX phantom placeholder" i
\phantom{$1}$0
endsnippet

snippet npha "LaTeX negative phantom placeholder" i
\phantom{-}$0
endsnippet

snippet xsol "LaTeX overline" iA
\overline{${1:${VISUAL}}}$0
endsnippet

snippet xsul "LaTeX underline" iA
\underline{${1:${VISUAL}}}$0
endsnippet

snippet co "LaTeX Cancel out" w
\cancel{${1:${VISUAL}}}$0
endsnippet

snippet col "LaTeX text color" i
{\color{#${1:ff0000}}{${2:${VISUAL}}}}$0
endsnippet

snippet coc "Cancel out with color" w
{\color{#${1:ff0000}}{\cancel{{\color{#${1:000000}}{${3:${VISUAL}}}}}}}$0
endsnippet

snippet nl "LaTeX empty line" bA
~\\\\
endsnippet

snippet begin "LaTeX begin function" bA
\begin{$1}
	${0:${VISUAL}}
\end{$1}
endsnippet

snippet bmat "LaTeX in-line brackets matrix" wb
\begin{bmatrix} ${1:${VISUAL}} \end{bmatrix}$0
endsnippet

snippet Bmat "LaTeX in-line curly braces matrix" wb
\begin{Bmatrix} ${1:${VISUAL}} \end{Bmatrix}$0
endsnippet

snippet pmat "LaTeX in-line parenthesis matrix" wb
\begin{pmatrix} ${1:${VISUAL}} \end{pmatrix}$0
endsnippet

snippet vmat "LaTeX in-line determinant matrix" wb
\begin{vmatrix} ${1:${VISUAL}} \end{vmatrix}$0
endsnippet

snippet Vmat "LaTeX in-line double absolute values matrix" wb
\begin{Vmatrix} ${1:${VISUAL}} \end{Vmatrix}$0
endsnippet

# Usage: arr[#column],[#row] ->
# \begin{array}{#column}
#   &*[column*row] \\
# \end{array}
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+),(\d+)ar' "LaTeX array" rbA
\begin{array}{`!p
orient = ""
for _ in range(0, int(match.group(1))): orient += "l"
snip.rv = orient`}
`!p
snip.rv = create_matrix(match.group(1), match.group(2), " & ", "\t", " \\\\\\\\\n")
`$0
\end{array}
endsnippet

# Usage: [#column]== ->
# \begin{aligned}
#   &=*[#columng] \\
# \end{array}
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)eq' "LaTeX block align equations" rbA
\begin{aligned}
`!p
snip.rv = create_matrix(2, match.group(1), " &= ","\t", " \\\\\\\\\n")
`
\end{aligned}$0
endsnippet

# Usage: "i((l or r)or(b))n,nm", where `i` (optional) is the in-line trigger
# either `l or r` (optional) as separators, `b` (optional) as the boundary type
# , and `n,n` as the matrix size (rows, column). No spaces and ignore
# parenthesis, and can't have both separators and boundary together.
post_jump "create_matrix_placeholders(snip)"
snippet '\b(i)?(((l)?(r)?)(b|B|v|V|p?))(\d+),(\d+)(m)?' "LaTeX matrix" wr
`!p
inline = match.group(1)
left = match.group(4) # left matrix separator
right = match.group(5) # right matrix separator
boundary = match.group(6) # boundary type

# Determine if in-line or block
indent = ""
if inline:
	inline = " "
else:
	inline = "\n"
	indent = "\t"

right_bound = "|" if match.group(9) == "m" else "."
if left or right:
	# Left boundary with right separator. Default boundary is "|"
	if left and right == None:
		if boundary:
			left = "\\left" + boundaries[f"{boundary}"][0]
			right = "\\right" + right_bound
		else:
			left = "\\left|"
			right = "\\right" + right_bound
	# Right boundary only
	elif left == None and right:
		if boundary:
			left = "\\left."
			right = "\\right" + boundaries[f"{boundary}"][1]
		else:
			left = "\\left."
			right = "\\right" + right_bound
	# Left and right separator
	elif left and right:
		if boundary:
			left = "\\left" + boundaries[f"{boundary}"][0]
			right = "\\right" + boundaries[f"{boundary}"][1]
		else:
			left = "\\left|"
			right = "\\right" + right_bound
	# Remove boundary
	boundary = ""
elif boundary:
	# No separator
	left = ""
	right = ""
else:
	# No boundary and separator
	left = ""
	right = ""
	boundary = ""
# Matrix size
rows = match.group(7)
cols = match.group(8)
# LaTeX matrix wrapper
begin = left + "\\begin{" + boundary + "matrix}" + inline
end = inline + "\\end{" + boundary + "matrix}" + right
result = "" # result value
placeholder = 1 # placeholder number for snippet jumps

# Matrix entries
result += create_matrix(rows, cols, " & ", indent, " \\\\\\\\" + inline)
snip.rv = begin + result + end
`$0
endsnippet

# Usage:
# item<tab> ->
# item
# item
snippet '(?<=\\item)(.+)' "LaTeX item" r
`!p snip.rv = match.group(1)`
\\item $0
endsnippet

# Usage:
# [number]item
# \begin{itemize}
#   item*[number]
# \end{itemiz}
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)item' "LaTeX itemize" brA
\begin{itemize}
`!p
res = "\t\\item $1"
if match.group(1):
	res = create_matrix(1, match.group(1), "", "\t\\item ", "\n")
	snip.rv = res
`
\end{itemize}$0
endsnippet

# Usage:
# [number]enum
# \begin{enumerate}
#   item*[number]
# \end{enumerate}
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)enum' "LaTeX enumerate" brA
\begin{enumerate}
`!p
res = "\t\\item $1"
if match.group(1):
	res = create_matrix(1, match.group(1), "", "\t\\item ", "\n")
	snip.rv = res
`
\end{enumerate}$0
endsnippet

# Usage:
# [number]desc
# \begin{description}
#   item*[number]
# \end{description}
post_jump "create_matrix_placeholders(snip)"
snippet '(\d+)desc' "LaTeX description" brA
\begin{description}
`!p
res = "\t\\item $1"
if match.group(1):
	res = create_matrix(1, match.group(1), "", "\t\\item ", "\n")
	snip.rv = res
`
\end{description}$0
endsnippet





# Brackets
# ============================================================

snippet bg) "LaTeX big parenthesis" iA
\bigl( ${1:${VISUAL}} \bigr)$0
endsnippet

snippet Bg) "LaTeX very big parenthesis" iA
\Bigl( ${1:${VISUAL}} \Bigr)$0
endsnippet

snippet bg] "LaTeX big brackets" iA
\bigl[ ${1:${VISUAL}} \bigr]$0
endsnippet

snippet Bg] "LaTeX big brackets" iA
\Bigl[ ${1:${VISUAL}} \Bigr]$0
endsnippet

snippet bg} "LaTeX very big braces" iA
\bigl\\{ ${1:${VISUAL}} \bigr\\}$0
endsnippet

snippet Bg} "LaTeX very big braces" iA
\Bigl\\{ ${1:${VISUAL}} \Bigr\\}$0
endsnippet

snippet bg| "LaTeX big pipe" iA
\bigl| ${1:${VISUAL}} \bigr|$0
endsnippet

snippet Bg| "LaTeX very big pipe" iA
\Bigl| ${1:${VISUAL}} \Bigr|$0
endsnippet

snippet bg\| "LaTeX big double pipe" iA
\bigl\\| ${1:${VISUAL}} \bigr\\|$0
endsnippet

snippet Bg\| "LaTeX very big double pipe" iA
\Bigl\\| ${1:${VISUAL}} \Bigr\\|$0
endsnippet

snippet lr) "LaTeX left right parenthesis" iA
\left ( ${1:${VISUAL}} \right )$0
endsnippet

snippet lr] "LaTeX left right brackets" iA
\left [ ${1:${VISUAL}} \right ]$0
endsnippet

snippet lr} "LaTeX left right braces" iA
\left \\{ ${1:${VISUAL}} \right \\}$0
endsnippet

snippet lr| "LaTeX left right pipe" iA
\left | ${1:${VISUAL}} \right |$0
endsnippet

snippet lr\| "LaTeX left right double pipe" iA
\left \| ${1:${VISUAL}} \right \|$0
endsnippet

snippet lr> "LaTeX left right double pipe" iA
\left < ${1:${VISUAL}} \right >$0
endsnippet

snippet lra "LaTeX angled brackets" iA
\langle ${1:${VISUAL}} \rangle$0
endsnippet

snippet lrc "LaTeX left right ceiling" iA
\lceil ${1:${VISUAL}} \rceil$0
endsnippet

snippet lrf "LaTeX left right floor" iA
\lfloor ${1:${VISUAL}} \rfloor$0
endsnippet

